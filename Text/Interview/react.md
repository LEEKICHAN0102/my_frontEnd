# Interview React

### Q. 리액트에 대해 아는 만큼 설명 해주세요.

- React에 대해 설명드리겠습니다. React는 사용자 인터페이스를 구축하기 위한 선언적, 효율적, 유연한 JavaScript 라이브러리입니다. Facebook에서 개발하고 관리하며, 주로 웹 애플리케이션의 프론트엔드 개발에 사용됩니다.React의 핵심 개념 중 하나는 컴포넌트 기반 아키텍처입니다. 

- 웹 애플리케이션을 독립적이고 재사용 가능한 작은 부분, 즉 '컴포넌트'로 나누어 구성합니다. 각 컴포넌트는 자신만의 상태(state)와 생명주기(lifecycle)를 가지며, 사용자 인터페이스를 구성하는 데 필요한 데이터와 로직을 포함합니다. 이러한 방식은 애플리케이션의 코드를 관리하고 유지하기 쉽게 만들어 줍니다.React의 또 다른 중요한 특징은 가상 DOM(Virtual DOM)입니다. 

- 전통적인 웹 개발 방식에서 DOM 조작은 성능 저하의 주요 원인 중 하나였습니다. React는 이 문제를 가상 DOM을 통해 해결합니다. 컴포넌트의 상태가 변경될 때마다, React는 가상 DOM을 사용하여 브라우저의 실제 DOM과 동기화하는 최적의 방법을 계산합니다. 이는 애플리케이션의 성능을 크게 향상시킵니다. React는 JSX라는 문법을 사용하여 컴포넌트의 구조를 선언합니다. JSX는 JavaScript와 HTML을 결합한 것으로 보이는 문법으로, 개발자가 UI 구조를 더 직관적으로 작성할 수 있게 해줍니다. 

- 이를 통해 개발자는 컴포넌트의 렌더링 로직을 효율적으로 작성하고 관리할 수 있습니다.또한, React는 단방향 데이터 흐름(one-way data flow)을 강조합니다. 데이터는 상위 컴포넌트에서 하위 컴포넌트로만 흐르며, 이는 애플리케이션 상태 관리를 더욱 명확하고 예측 가능하게 만듭니다.React는 다양한 에코시스템과 함께 사용됩니다. 

- 예를 들어, 상태 관리를 위해 Redux나 Context API가 사용되며, 라우팅을 위해서는 React Router가 사용됩니다. 또한, 서버 사이드 렌더링을 위해 Next.js 같은 프레임워크와 결합될 수 있습니다.마지막으로, React의 인기는 그 유연성과 확장성, 커뮤니티의 지원 덕분에 계속 증가하고 있습니다. 이는 개발자가 빠르게 변화하는 웹 개발 환경에 능동적으로 대응할 수 있게 해주며, 다양한 규모와 요구사항을 가진 프로젝트에 적용될 수 있습니다.

<br>
<br>
<br>

### Q. React의 Virtual DOM은 실제 DOM과 어떻게 다른가요?

- React의 Virtual DOM은 실제 DOM과 비교하여 더 효율적인 렌더링 방식을 제공합니다. 실제 DOM은 웹 페이지의 구조를 나타내는 데 사용되는 브라우저의 표준 API이며, DOM 요소를 변경하면 페이지의 일부 또는 전체가 다시 렌더링됩니다. 이 과정은 성능에 부담을 줄 수 있습니다. 

- 반면, React의 Virtual DOM은 이러한 실제 DOM을 가볍게 모방한 자바스크립트 객체입니다. 컴포넌트의 상태가 변경될 때, React는 먼저 Virtual DOM에 이 변경사항을 빠르게 적용하고, 변경 전후의 Virtual DOM을 비교하는 과정인 'Diffing'을 통해 실제 DOM에 필요한 최소한의 변경사항만을 적용합니다. 이 방식은 불필요한 DOM 조작을 줄여 성능을 향상시키고, 효율적인 페이지 업데이트를 가능하게 하며, 결과적으로 사용자 경험을 개선합니다.

<br>
<br>
<br>

### Q. React에서의 상태관리는 어떻게 이루어지나요? 

- React에서 상태 관리는 애플리케이션의 다양한 컴포넌트에서 사용자 인터랙션, 데이터 흐름 및 UI 변경을 관리하는 핵심적인 부분입니다. 기본적으로, React는 내장된 상태 관리 기능을 제공합니다. 각 컴포넌트는 자체적인 상태(state)를 가지며, 이 상태는 해당 컴포넌트 또는 그 자식 컴포넌트에 영향을 줄 수 있습니다. 상태가 변경되면 React는 컴포넌트를 다시 렌더링하여 UI를 최신 상태로 유지합니다.

- 단일 컴포넌트 또는 소규모 애플리케이션에서는 React의 useState 훅을 사용하여 상태를 관리할 수 있습니다. 이 훅을 통해 컴포넌트 내부에서 상태를 생성하고, 상태 변경 함수를 통해 상태를 업데이트할 수 있습니다. 또한, useEffect와 같은 훅을 사용하여 외부 데이터 소스와의 상호작용이나 부수 효과를 처리할 수 있습니다.

- 그러나 애플리케이션이 복잡해지고 여러 컴포넌트 간의 상태 공유가 필요해지면, 상태 관리의 복잡성이 증가합니다. 이 경우, 전역 상태 관리 라이브러리인 Redux, MobX, Context API와 같은 솔루션을 사용할 수 있습니다. 예를 들어, Redux는 애플리케이션의 상태를 하나의 중앙 저장소(store)에서 관리하며, 이를 통해 예측 가능한 상태 관리가 가능합니다. Redux는 액션(action)을 통해 상태 변경을 요청하고, 리듀서(reducer)를 통해 상태를 업데이트합니다. 이러한 패턴은 대규모 애플리케이션에서 상태 관리를 일관되고 효율적으로 만들어 줍니다.

- React의 Context API는 또 다른 방법으로, 컴포넌트 트리 전반에 걸쳐 데이터를 전달하는 방법을 제공합니다. 이를 통해 props 드릴링(props drilling, 즉 부모 컴포넌트에서 자식 컴포넌트로 props를 계속 전달하는 것)의 필요성을 줄일 수 있습니다.

<br>
<br>
<br>

### Q. 클래스형 컴포넌트와 함수형 컴포넌트의 차이가 무엇인가요?

- 클래스 컴포넌트와 함수형 컴포넌트는 React에서 컴포넌트를 정의하는 두 가지 주요 방식입니다. 이들의 차이점은 주로 문법, 상태 관리 방식, 라이프사이클 메소드의 사용 여부에서 드러납니다.

- 클래스 컴포넌트는 ES6의 클래스를 활용하여 정의됩니다. 이러한 컴포넌트는 this 키워드를 사용하여 인스턴스 변수와 메소드에 접근하고, 상태(state)와 생명주기 메소드를 사용할 수 있습니다. 생명주기 메소드는 컴포넌트가 마운트, 업데이트, 언마운트될 때 특정 작업을 수행하도록 해주며, 이를 통해 개발자는 더 세밀한 컨트롤이 가능합니다. 예를 들어, componentDidMount, componentDidUpdate, componentWillUnmount와 같은 메소드들은 컴포넌트의 생명주기에 따라 특정 동작을 정의하는 데 사용됩니다.

- 함수형 컴포넌트는 보다 간결하고, 함수로 구현되며, 클래스 기반 컴포넌트보다 선언적입니다. 초기 React에서는 함수형 컴포넌트가 상태를 가질 수 없고, 오직 props를 받아 렌더링만 수행하는 무상태 컴포넌트로 사용되었습니다. 그러나 React 16.8부터 도입된 훅(Hooks)을 통해 함수형 컴포넌트에서도 상태 관리(useState), 부수 효과 관리(useEffect), 컨텍스트(useContext) 등을 할 수 있게 되었습니다. 이로 인해 함수형 컴포넌트는 클래스 컴포넌트와 유사한 기능을 제공하면서도 더 간결하고 쉬운 문법으로 작성할 수 있게 되었습니다.

- 요약하자면, 클래스 컴포넌트는 상태 관리와 생명주기 메소드를 사용하는 더 전통적인 방법을 제공하는 반면, 함수형 컴포넌트는 훅을 사용하여 보다 간결하고 현대적인 방식으로 같은 기능을 구현할 수 있습니다. React 개발의 최근 추세는 함수형 컴포넌트와 훅의 사용을 선호하는 방향으로 이동하고 있습니다.

<br>
<br>
<br>

### Q. React에서 props와 state의 차이가 무엇인가요?

- React에서 props와 state는 컴포넌트의 데이터 흐름과 상태 관리를 다루는 핵심 개념이며, 이들은 서로 다른 목적과 사용 방식을 가집니다. 

- Props는 Properties의 약자로, 부모 컴포넌트로부터 자식 컴포넌트로 데이터를 전달하는 데 사용됩니다. 이들은 읽기 전용이며, 컴포넌트 내부에서는 수정될 수 없습니다. Props를 통해 컴포넌트는 외부에서 받은 데이터를 기반으로 렌더링을 하며, 이를 통해 재사용성과 유지 보수성이 높은 컴포넌트를 만들 수 있습니다. 

- 반면, State는 컴포넌트 내부에서 선언되며, 컴포넌트의 상태를 관리하는 데 사용됩니다. State는 변경 가능하며, 상태가 변경될 때마다 컴포넌트는 자동으로 재렌더링됩니다. 이를 통해 사용자 인터페이스는 상호작용이나 시간의 경과에 따라 동적으로 반응할 수 있습니다. 예를 들어, 폼 입력, 타이머, 사용자 인터랙션과 같은 변화하는 데이터는 state로 관리됩니다. 

- 이처럼 props와 state는 각각 불변성과 변화 가능성이라는 특성을 가지며, 이를 통해 React는 효율적이고 예측 가능한 방식으로 UI를 렌더링하고 업데이트합니다.

<br>
<br>
<br>

### Q. React에서 생명주기 메서드란 무엇이고 언제 사용하나요?

- React에서 생명주기 메서드란 클래스 기반 컴포넌트가 생성, 업데이트, 파괴되는 과정에서 발생하는 일련의 이벤트를 처리하는 메서드들을 말합니다. 이 메서드들은 컴포넌트의 생명주기 동안 특정 시점에 자동으로 호출되며, 개발자는 이를 통해 컴포넌트의 동작을 제어하고, 필요한 로직을 실행할 수 있습니다. 

- 주요 생명주기 메서드는 마운팅, 업데이트, 언마운팅의 세 단계로 나뉩니다. 마운팅 단계에서는 constructor(), render(), componentDidMount() 등의 메서드가 호출되며, 여기서 컴포넌트의 초기 설정, DOM 렌더링, 외부 데이터 요청 등이 이루어집니다. 

- 업데이트 단계는 컴포넌트의 props 또는 state 변경 시 발생하며, 이때 render()와 componentDidUpdate() 메서드가 실행되어 변경된 상태에 따른 추가적인 처리를 할 수 있습니다. 

- 마지막으로, 언마운팅 단계에서는 componentWillUnmount() 메서드가 호출되어 컴포넌트 제거 전에 필요한 정리 작업(타이머 제거, 네트워크 요청 취소 등)을 수행합니다. 

- 이러한 생명주기 메서드를 활용함으로써, 개발자는 컴포넌트의 생성부터 소멸까지의 과정을 세밀하게 관리하고, 애플리케이션의 성능 최적화 및 안정적인 리소스 관리를 할 수 있습니다.

<br>
<br>
<br>

### Q. React에서 hooks은 무엇이고 언제 사용하나요?

- React에서 훅(Hooks)은 함수형 컴포넌트에서 상태 관리 및 다양한 React 기능을 사용할 수 있도록 하는 함수들입니다. React 16.8 버전에서 도입된 이후, 클래스 기반 컴포넌트에서만 가능했던 여러 기능들을 함수형 컴포넌트에서도 사용할 수 있게 되었습니다. 

- 대표적인 훅에는 useState, useEffect, useContext 등이 있습니다. useState는 함수형 컴포넌트 내에서 상태를 관리할 수 있게 해주며, 상태 변수와 해당 상태를 업데이트하는 함수를 반환합니다. 이를 통해 컴포넌트의 상태를 변경하고 재렌더링을 유발할 수 있습니다. 

- useEffect는 컴포넌트의 렌더링 결과가 화면에 반영된 후에 실행되는 부수 효과(Side Effects)를 처리합니다. 예를 들어, 데이터 가져오기, 구독 설정, 수동으로의 DOM 조작 등이 여기에 해당합니다. useEffect는 또한 클린업 함수를 반환하여 부수 효과를 정리할 수 있습니다. 

- useContext는 컨텍스트(Context)를 통해 전역적인 데이터를 관리할 수 있게 해주는 훅으로, props 드릴링 없이 컴포넌트 트리 전반에 걸쳐 데이터를 공유할 수 있습니다. 

- 이외에도 여러 커스텀 훅(Custom Hooks)을 만들어 사용할 수 있으며, 이는 코드 재사용성과 구조의 단순화에 크게 기여합니다. 훅은 함수형 컴포넌트의 코드를 더 간결하고 읽기 쉽게 만들며, 상태 관리와 다른 React 기능들을 더 효율적으로 사용할 수 있게 해줍니다.

<br>
<br>
<br>

### React에서 Key는 무엇이고 어떤 역할을 하나요?

- React에서 키(key)의 주요 역할은 컴포넌트 목록을 효율적으로 렌더링하고 관리하는 것입니다. 키는 각 목록 항목의 고유성을 식별하는 데 사용되며, React에게 각 요소를 구별할 수 있는 방법을 제공합니다. 

- 특히 목록의 항목이 추가, 삭제, 재정렬될 때, React는 키를 사용하여 어떤 항목이 변경되었는지를 판단하고 필요한 항목만을 효율적으로 업데이트합니다. 이는 불필요한 리렌더링을 방지하고, 애플리케이션의 성능을 개선하는 데 중요합니다. 

- 예를 들어, 목록을 렌더링할 때 각 항목에 고유한 값을 키로 할당하면, 항목이 추가되거나 제거될 때 React는 기존 목록과 새 목록을 키를 기준으로 비교하여 최소한의 DOM 업데이트만을 수행합니다. 

- 일반적으로 키로는 데이터의 ID나 고유한 값을 사용하며, 이는 React가 각 요소를 효과적으로 식별하고, 목록의 변경을 빠르게 처리하는 데 도움을 줍니다. 키의 올바른 사용은 React 애플리케이션의 성능 최적화에 매우 중요한 요소입니다.

<br>
<br>
<br>

### Q. 공용 컴포넌트를 개발할 때 주의 해야할 점에 대해 설명해주세요.

- 공용 컴포넌트를 개발할 때는 여러 가지 중요한 측면을 고려해야 합니다. 공용 컴포넌트는 다양한 곳에서 재사용될 수 있으므로, 범용성, 유지보수 용이성, 성능 등 여러 면에서 효율적이어야 합니다.

- 첫째, 범용성과 유연성을 확보해야 합니다. 공용 컴포넌트는 다양한 사용 사례와 환경에서 사용될 수 있으므로, 범용적이고 확장 가능한 설계가 중요합니다. 이를 위해, 컴포넌트의 인터페이스는 간결하면서도 충분히 유연해야 하며, 다양한 상황에서도 잘 작동할 수 있도록 설계해야 합니다.

- 둘째, 명확한 API 문서화가 필요합니다. 공용 컴포넌트를 사용하는 다른 개발자들이 쉽게 이해하고 사용할 수 있도록, 모든 속성과 메서드, 이벤트 핸들러 등에 대한 자세한 문서를 제공해야 합니다. 이는 컴포넌트의 사용 방법과 예상되는 동작을 명확하게 전달하는 역할을 합니다.

- 셋째, 견고한 에러 핸들링이 중요합니다. 공용 컴포넌트는 예상치 못한 상황이나 오류를 적절히 처리할 수 있어야 합니다. 이는 컴포넌트가 안정적으로 동작하고, 오류 발생 시 적절한 피드백을 제공할 수 있도록 하는 데 필요합니다.

- 넷째, 성능 최적화를 고려해야 합니다. 공용 컴포넌트는 성능에 큰 영향을 미칠 수 있으므로, 불필요한 렌더링을 피하고, 메모리 사용을 최적화하는 등 성능에 대한 고려가 필요합니다.

- 다섯째, 스타일링의 유연성을 제공해야 합니다. 다양한 프로젝트에서 사용될 수 있도록 컴포넌트의 스타일링은 쉽게 커스터마이징할 수 있어야 합니다. 이를 위해 CSS 클래스와 인라인 스타일, 테마 지원 등 다양한 스타일링 옵션을 제공하는 것이 좋습니다.

- 마지막으로, 테스트의 용이성을 보장해야 합니다. 공용 컴포넌트는 다양한 환경에서 오류 없이 작동해야 하므로, 단위 테스트, 통합 테스트 등을 통해 충분히 검증되어야 합니다. 테스트를 통해 컴포넌트의 안정성을 보장하고, 유지보수를 용이하게 할 수 있습니다.

<br>
<br>
<br>

### 리액트에서 어떤 식으로 성능 최적화를 할 수 있을까요?

- 리액트 성능 최적화를 위한 여러가지 방법이 존재하지만 대표적으로 메모이제이션이 존재합니다. 

- 리액트의 memo를 사용하여 컴포넌트를 메모이제이션할 수 있습니다. 이는 컴포넌트의 props가 변경되지 않았을 때, 리렌더링을 방지하여 성능 최적화가 가능합니다 특히 렌더링 비용이 큰 컴포넌트에서 유용합니다.

- 또는 useCallback & useMemo도 사용이 가능합니다. useCallback의 경우 함수를 메모이제이션하여 불필요한 함수 재생성을 방지, useMemo는 값의 재계산을 방지하여 최적화에 도움을 줄 수 있습니다. 이를 통해 자식 컴포넌트로 전달되는 함수나 값이 변경되지 않으면 리렌더링을 피할 수 있습니다.

- 또는 코드스플리팅을 예로 들 수 있는데, 코드 스플리팅은 큰 애플리케이션을 여러 개의 작은 청크로 나누어, 필요한 청크만 로드하게 하여 초기 로드 시간을 줄입니다. React.lazy와 Suspense를 사용하여 동적으로 컴포넌트를 로드할 수 있습니다.

- 코드 스플리팅은 초기 로딩 시간이 길어지는 경우 사용할 수 있습니다. 애플리케이션이 커지면, 초기 로딩에 모든 코드를 로드하는 것이 비효율적일 수  있기때문에 초기 로드 시 필요한 핵심 코드만 로드하고, 이후 추가적인 기능은 필요할 때 로드하도록 구성할 수 있습니다. 또는 라우트별 코드 분할이 필요할 때 SPA에서는 각 페이지가 별도의 기능과 UI를 가지므로, 라우트별로 필요한 코드만 분리하여 로드할 수 있습니다. 이 방식은 리액트의 React.lazy와 Suspense를 사용하여 라우트별 컴포넌트를 동적으로 불러올 때 유용합니다.

<br>
<br>
<br>


### 리액트의 Strict Mode란 무엇인지 설명해주세요.

- StrictMode는 주로 개발 중에 발생할 수 있는 잠재적인 문제를 사전에 감지하고 예방하기 위해 사용되는데 몇 가지 주요 목적을 가지고 있습니다.

- 첫 째로 오래된 라이프사이클 메서드와 비권장 API의 사용을 감지합니다. 예를 들어 componentWillMount, componentWillReceiveProps 와 같은 메서드는 더 이상 사용이 권장 되지 않는데, StrictMode는 이러한 메서드들이 코드에 포함 된 경우 경고를 표시해줍니다. 이를 통해 개발자가 최신 React API를 사용하여 보다 안정적이고 효율적인 코드를 작성할 수 있도록 돕습니다.

- 또한 의도치 않은 부수 효과를 방지합니다. 리액트는 컴포넌트의 렌더링이 예측 가능하고 순수하게 이루어지기를 기대하는데 StrictMode는 이를 검증하기 위해 useEffect, useState 등 일부 훅이나 메서드를 두 번씩 실행 시킵니다. 이렇게 두 번 실행이 되는 이유는, 동일한 결과가 나오는지를 확인함으로써 컴포넌트가 사이드 이펙트를 일으키지 않고 순수하게 동작하는지를 검사하기 위함입니다.

- 예기치 않은 동작, 버그를 사전에 방지하기 위해 위의 검증은 중요합니다. 개발환경에서 두 번씩 실행 하였으나 문제가 발생하지 않는다면 프로덕션에서도 안전하게 실행 된다는 신호라는 것을 알 수 있기 때문입니다. 실제 프로덕션에서는 한 번만 실행 되기 때문에 성능에는 영향을 끼치지 않습니다. 

<br>
<br>
<br>

### 리액트의 render phase & commit phase

- 리액트의 렌더링 과정은 크게 두가지로 나뉘는데 바로 render phase & commit phase 입니다.

- render phase는 리액트가 변화된 상태나 props에 따라 어떤 UI가 변경 되어야 하는지를 결정하는 단계를 말합니다. 이 과정에서는 실제로 DOM을 업데이트하지 않고 변경사항을 가상 DOM에서 계산하여 비교하는데, 순수하게 계산을 하는 과정이기 때문에 성능에 영향을 주지 않도록 중단되거나 다시 실행 될 수 있으며, 18에서 도입 된 Concurrent Mode를 통해 비동기적으로 처리될 수도 있습니다.

- commit phase는 실제로 변화된 UI를 DOM에 반영하는 단계입니다. 이때 리액트는 가상 DOM에서 계산 된 결과를 실제 DOM에 적용하고 변화된 UI를 브라우저에 렌더링합니다. 이 과정에서 useEffect와 같은 사이트 이펙트가 발생하는 훅들이 실행됩니다.

- 요약하자면 render phase는 변화 된 UI를 결정하는 계산 과정, commit phase는 계산 된 결과를 실제로 반영하는 단계를 말합니다.

<br>
<br>
<br>

### 리액트의 Controlled Component와 Uncontrolled Component란 무엇인지 언제 사용할 수 있는지 설명해주세요.

- Controlled Component란 리액트의 상태(state)를 통해 입력 값을 제어하는 컴포넌트를 말합니다. 입력 요소의 값(value)을 리액트 상태와 동기화 하고 사용자가 입력을 변경할 때마다 onChange 이벤트 핸들러를 통해 상태를 업데이트합니다. 

- 예시로 useState를 활용한 input value를 제어하는 상황을 말할 수 있는데, value는 리액트의 상태로 관리되며 onChange 이벤트가 발생할 때마다 상태가 업데이트 됩니다. 주요 장점은 입력값이 리액트의 상태로 관리 되므로 값을 쉽게 검증, 변경할 수 있고 복잡한 폼 로직을 처리하는데에 유리하다는 것이 있습니다.

- Uncontrolled Component는 리액트의 상태가 아닌, DOM 자체가 입력값을 제어하는 방식을 말합니다. 입력 요소의 값은 DOM에서 직접 관리되며, 리액트는 이를 제어하지 않습니다. 이 방식에서는 ref를 사용하여 DOM 요소에 직접 접근해 값을 읽거나 조작할 수 있습니다.

- input과 관련 된 ref는 useRef를 사용해 생성된 참조 객체로, 입력값을 직접 접근하고 조작할 수 있습니다. Uncontrolled Component는 상대적으로 간단한 폼이나 초기값이 중요한 상황에서 사용할 수 있습니다.

- ref를 사용하면 DOM을 통해 직접 접근하여 값을 읽어오기때문에, 단순한 입력 필드가 포함된 폼에서 ref를 사용하는 것이 더 간단하고 성능이 좋을 수 있습니다. 사용자가 제출 버튼을 클릭했을 때만 입력값을 가져오면 되는 경우를 예로 들 수 있습니다. 만약에 값을 입력할때마다 유효성 검증을 실시간을 해주어야하는 경우에는 Controlled Component를 사용하는 것이 좋습니다.

<br>
<br>
<br>

### tanstack-query에서 stale time과 gc time의 차이점에 대해서 설명해주세요.

- TanStack Query에서 stale time과 gc time은 데이터를 캐싱하고 관리하는 데 중요한 두 가지 설정입니다. 

- stale time은 데이터가 얼마나 오래 "신선한 상태"로 유지 되는지를 정하는 것이고 gc time은 데이터가 오래된 상태가 된 이후에도 캐시에서 얼마동안 유지 될지를 정하는 시간을 말합니다.

- 위 말대로 stale time 은 데이터를 초기에 가져온 후 추가적인 네트워크 요청이 일어나지 않고 캐시에 저장 된 데이터를 그대로 사용하게 됩니다. 5분으로 설정 했다고 할 때 데이터를 가져오고 5분 동안은 데이터가 신선하기 때문에 교체할 필요가 없다고 판단하기에 캐시 된 데이터를 계속 해서 사용하는 것 입니다. stale time 의 기본 값은 '0'

- gc time은 오래된 상태의 데이터를 캐시에 얼마동안 저장할지를 결정하는 시간입니다. stale time이 5분이라고 할 때 5분이 지난 후 "오래 된 상태"의 데이터가 되는데 gc time 을 10분으로 설정하였을 때 초기 데이터를 가져온 후 15분 이후에 다시 신선한 데이터를 가져오는 네트워크 요청을 보낸다는 것을 알 수 있습니다. gc time 의 기본 값은 '5'

- 따라서 별도의 설정을 하지 않은 경우 Tanstack-Query 에서 데이터를 초기에 가져온 후 직후에 데이터가 '오래 된 상태'라고 판단하고 gc time 의 기본 값 만큼 유지 된 후 새로운 데이터를 요청한다는 사실을 알 수 있습니다. stale time과 gc time 을 통해 불필요한 데이터 요청을 줄이면서 최신 데이터를 가져올 수 있도록 핸들링이 가능합니다.

<br>
<br>
<br>
