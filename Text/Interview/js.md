# Interview JS

### 자바스크립트 클로저에 대해 설명해주세요

- 클로저는 함수가 선언될 때의 스코프를 기억하여, 함수가 생성된 이후에도 그 스코프에 접근할 수 있는 기능을 말합니다. 비유하자면, 함수가 자신이 생성된 환경을 '기억'하는 것이라고 할 수 있습니다. 클로저는 자바스크립트의 함수가 일급 객체라는 특성과 렉시컬 스코프의 조합으로 만들어집니다.

```
// 클로저의 예시

function outerFunction(outerVariable) {
  return function innerFunction(innerVariable) {
    console.log('Outer Variable: ' + outerVariable);
    console.log('Inner Variable: ' + innerVariable);
  };
}

const newFunction = outerFunction('outside');
newFunction('inside');
```

- innerFunction은 outerFunction의 내부에 정의 되어있습니다. innerFunction은 자신이 생성된 스코프, 즉 outerFunction의 스코프를 기억하고, outerFunction의 호출이 완료된 이후에도 그 스코프에 접근이 가능합니다. => innerFunction은 outerVariable에도 접근이 가능!

- newFunction은 outerFunction에 'outside' 라는 인자넣은 함수를 초기화 하였고, outerVariable === 'outside' 가 되는 것은 당연한 결과인데 이때 newFunction을 'inside' 인자를 넣은 후 호출하면 return 값에 해당 되는 인자는 innerFunction에 해당하게 됩니다. 자신이 생성 된 스코프를 기억하고 있기 때문에 outerFunction 호출 이후에도 접근이 가능하기떄문!

- 클로저는 데이터 은닉,  비동기 작업, 모듈 패턴 구현 등 사용이 가능합니다. 변수와 함수의 접근 범위를 제어하고 특정 데이터와 상태를 유지하기 용이하기에 위 작업에 도움이 될 수 있습니다.

<br>
<br>
<br>

### 자바스크립트 호이스팅

- 호이스팅(Hoisting)은 자바스크립트가 코드를 실행하기 전에 변수와 함수 선언을 코드의 최상단으로 끌어올리는 것 처럼 동작하는 특징을 말합니다.

- 이는 마치 코드가 선언된 위치와 관계 없이 변수를 사용할 수 있는 것 처럼 보이기도 하는데 호이스팅은 선언의 호이스팅일 뿐, 변수의 값 할당까지 끌어올려지지는 않습니다. var로 선언 된 변수는 선언 자체는 호이스팅되지만 초기화 되기 전까지는 undefined로 평가 됩니다. 함수의 경우 전체가 호이스팅되기 때문에, 함수 호출을 선언 이전에 해도 문제가 되지는 않습니다.

```
// variable
console.log(myVar); // undefined

var myVar = 10;
console.log(myVar); // 10

//function
console.log(myFunction()); // 'Hello World' 출력

function myFunction() {
  return 'Hello World';
}
```

- ES6에서 도입 된 let와 const 키워드는 호이스팅이 되긴 하지만 선언하기전에 접근하려고 하면 ReferenceError가 발생합니다. 

- 이는 Temporal Dead Zone(TDZ)이라는 개념 때문인데 TDZ는 변수가 선언 되었지만 초기화 되기 전까지의 구간을 말합니다. let, const 로 선언 된 변수는 TDZ가 존재하며 이 구간에서는 변수에 접근할 수 없습니다.

- 따라서 호이스팅은 변수와 함수 선언을 코드 상단으로 끌어올리는 것처럼 동작하지만, var는 선언만 호이스팅되어 초기화 전에 undefined가 되며, let과 const는 TDZ로 인해 초기화 전에 접근하면 ReferenceError를 발생시킨 다는 것을 알 수 있습니다.

<br>
<br>
<br>

### 실행 컨텍스트에 대해서 설명해주세요.

- 실행 컨텍스트란 자바스크립트에서 코드가 실행되는 환경을 의미합니다. 자바스크립트 엔진이 코드를 실행할 때, 그 코드가 실행될 때의 환경을 정의하고 관리하기 위해 존재하는 것이 바로 실행 컨텍스트입니다.

- 이 실행 컨텍스트는 크게 전역 실행 컨텍스트, 함수 실행 컨텍스트로 나뉘어지는데 전역 실행 컨텍스트의 경우 자바스크립트가 처음 실행될 떄 생성됩니다. 프로그램이 종료될 때 까지 유지되며, 전역에서 선언된 변수와 함수가 모두 포함되며 프로그램 내 어디서든 접근이 가능하다는 특징이 있습니다. JS 는 싱글 스레드이기 때문에 전역 실행 컨텍스트는 1개만 존재합니다.

- 함수 실행 컨텍스트는 함수가 호출될 때마다 생성 되는 컨텍스트를 의미합니다. 각 함수는 자신만의 실행 컨텍스트를 가지며, 이 컨텍스트 내에서 선언된 변수와 함수는 해당 함수 내에서만 유효하기에 함수가 종료되면 그 실행 컨텍스트도 함께 사라지게 됩니다.

<br>
<br>
<br>

### 실행 컨텍스트의 구성요소

- 변수 객체, 스코프 체인, this 의 구성요소로 이루져 있습니다.

- 변수 객체란 실행 컨텍스트 내에서 사용 되는 변수와 함수 선언을 저장하는 공간을 말합니다. 전역 객체가 변수 객체의 역할을 하고, 함수 컨텍스트에서는 활성화 객체가 변수와 매개변수를 관리합니다.

- 스코프 체인의 경우 실행 중인 컨텍스트와 외부 렉시컬 환경의 연결을 유지합니다. 변수를 참조할 때 현재 컨텍스트에서 찾지 못하면 외부 환경으로 범위를 넓혀가며 변수를 찾습니다.

- this 는 실행 컨텍스트에 따라 참조하는 객체가 달라지는데 전역 컨텍스트에서 this는 전역 객체를 가리키며, 함수 컨텍스트에서는 함수 호출 방법에 따라 달라지게 됩니다.

- 실행 컨텍스트는 이러한 구성 요소를 통해 자바스크립트 코드가 실행되는 동안의 환경을 관리하고, 코드 실행 시 변수의 유효 범위 또는 함수 호출 맥락을 결정 짓습니다.

[실행 컨텍스트란 무엇인가?](https://www.youtube.com/watch?v=EWfujNzSUmw)

<br>
<br>
<br>

### 이벤트 루프에 대해서 설명해주세요.

- 자바스크립트의 이벤트루프는 JS가 싱글 스레드 기반 언어임에도 불구하고 비동기 작업을 가능하게 하는 중요한 메커니즘입니다.

- 기본적으로 한 번에 하나의 작업만을 처리하는 JS 이지만 이벤트 루프가 콜 스택, 태스크 큐를 관리하면서 비동기 작업이 완료 되었을 때 그 결과를 처리할 수 있도록 도와줍니다. 콜 스택이란 현재 실행 중인 코드들이 쌓이는 곳, 태스크 큐는 비동기 작업이 완료되면 그 결과를 대기 시키는 곳입니다.

- setTimeout(callback, 0)를 예시로 들 수 있는데, 인자로 콜백 함수와 stale time 을 받는 setTimeout과 같은 경우 호출 시 바로 실행 되는 것이 아닌 웹 API에 의해 타이머가 설정 되고, 타이머가 0ms 이후 만료되면서 콜백 함수가 태스크 큐에 추가가 됩니다. 그 후 콜 스택이 비어있는 시점에서 이벤트 루프는 태스크 큐에 대기중인 결과인 callback을 실행하게 됩니다.

- setTimeout을 호출하여도 현재 실행 중인 모든 동기 작업들이 완료된 후에야 콜백이 실행되게 됩니다. setTimeout을 사용하여 코드의 실행을 다음 이벤트루프 사이클로 미루는 것이 가능합니다.

<br>
<br>
<br>

### 태스크 큐의 종류?

- 크게 매크로태스크 큐, 마이크로태스크 큐로 나뉘어집니다. 

- 매크로태스크 큐의 경우 setTimeout, setInterval 같은 일반적인 비동기 작업들이 대기하는 큐이고 이 작업은 이벤트 루프가 콜 스택 & 마이크로 태스크 큐의 작업을 모두 처리한 후에 하나씩만 처리합니다.

- 마이크로태스크 큐는 Promise.then()과 같이 중요도가 높은 작업들이 대기하는 큐를 말합니다. 마이크로태스크 큐는 매크로태스크 큐보다 우선순위가 높기때문에 이벤트 루프는 콜 스택이 비어있는 시점에 매크로태스크를 실행하기 이전에 마이크로태스크 큐에 있는 모든 작업들을 먼저 처리합니다.

<br>
<br>
<br>

