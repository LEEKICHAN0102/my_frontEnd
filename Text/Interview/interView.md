# 면접 질문

- 매일메일의 면접 예상 질문과 답변을 정리한 MD 형식의 문서

<br>

### 클로저에 대해 설명해주세요

- 클로저는 함수가 선언될 때의 스코프를 기억하여, 함수가 생성된 이후에도 그 스코프에 접근할 수 있는 기능을 말합니다. 비유하자면, 함수가 자신이 생성된 환경을 '기억'하는 것이라고 할 수 있습니다. 클로저는 자바스크립트의 함수가 일급 객체라는 특성과 렉시컬 스코프의 조합으로 만들어집니다.

```
// 클로저의 예시

function outerFunction(outerVariable) {
  return function innerFunction(innerVariable) {
    console.log('Outer Variable: ' + outerVariable);
    console.log('Inner Variable: ' + innerVariable);
  };
}

const newFunction = outerFunction('outside');
newFunction('inside');
```

- innerFunction은 outerFunction의 내부에 정의 되어있다. innerFunction은 자신이 생성된 스코프, 즉 outerFunction의 스코프를 기억하고, outerFunction의 호출이 완료된 이후에도 그 스코프에 접근이 가능하다. => innerFunction은 outerVariable에도 접근이 가능!

- newFunction은 outerFunction에 'outside' 라는 인자넣은 함수를 초기화 하였음. outerVariable === 'outside' 가 되는 것은 당연한 결과. 이때 newFunction을 'inside' 인자를 넣은 후 호출하면 return 값에 해당 되는 인자는 innerFunction에 해당하게 됨. 자신이 생성 된 스코프를 기억하고 있기 때문에 outerFunction 호출 이후에도 접근이 가능하기떄문!

- 클로저는 데이터 은닉,  비동기 작업, 모듈 패턴 구현 등 사용이 가능하다. 변수와 함수의 접근 범위를 제어하고 특정 데이터와 상태를 유지하기 용이하기에 위 작업에 도움이 될 수 있다.

<br>
<br>

### reflow와 repaint의 차이점에 대해서 설명해주세요.

- 우선 reflow와 repaint 가 무엇인지 알아볼 필요가 있다. reflow는 브라우저가 페이지의 레이아웃을 다시 계산하는 과정을 말한다. DOM, CSS 스타일 등이 변하게 되면 브라우저는 각 요소가 화면에 어떻게 배치될지 다시 계산하기에 자식 요소와 관련된 부모 요소까지 영향을 끼치기 때문에 비용이 많이 드는 작업이다.

- repaint는 요소의 모양이나 스타일이 변경 될 떄 발생한다. 레이아웃은 동일하나 색상, 배경 등 스타일이 변경 되는 경우를 말한다(background-color 등). reflow보다는 비용이 덜 들지만 성능에 영향을 끼칠 수는 있다.

- 쉽게 비유해서 reflow가 집을 다시 짓는 과정이라고 하면 repaint는 말그대로 페인트칠만 다시하는 것이라고 생각할 수 있다. 레이아웃을 처음부터 계산 하는 과정 <=> 계산 결과를 화면에 다시 그리는 과정.

- reflow와 repaint를 어떻게 관리하는 것이 성능 최적화에 도움을 줄 수있을까?

1. reflow를 유발하는 CSS 속성 사용의 최소화가 방법이 될 수 있다. width, height, margin, padding 등의 속성은 요소의 레이아웃을 다시 계산하기 떄문에 reflow를 일으키기에 CSS 스타일을 설정해 초기 로드시에만 이루어지고 이후에는 변경되지 않도록 하는것이 BEST!

2. CSS 애니메이션의 최적화 방법이 있다. 애니메이션 transform & opacity 속성만을 사용하는 것이 성능에 유리하다. 이 둘의 경우 GPU 가속을 사용할 수 있어 reflow 가 아닌 repaint만 발생 시키기에 자원을 적게 사용이 가능하다.

<br>
<br>

### 실행 컨텍스트에 대해서 설명해주세요.

- 실행 컨텍스트란 자바스크립트에서 코드가 실행되는 환경을 의미한다. 자바스크립트 엔진이 코드를 실행할 때, 그 코드가 실행될 때의 환경을 정의하고 관리하기 위해 존재하는 것이 바로 실행 컨텍스트.

- 이 실행 컨텍스트는 크게 전역 실행 컨텍스트, 함수 실행 컨텍스트로 나뉘어지는데 전역 실행 컨텍스트의 경우 자바스크립트가 처음 실행될 떄 생성된다. 프로그램이 종료될 때 까지 유지되며, 전역에서 선언된 변수와 함수가 모두 포함되며 프로그램 내 어디서든 접근이 가능하다는 특징이 있다. JS 는 싱글 스레드이기 때문에 전역 실행 컨텍스트는 1개만 존재한다.

- 함수 실행 컨텍스트는 함수가 호출될 때마다 생성 되는 컨텍스트를 의미한다. 각 함수는 자신만의 실행 컨텍스트를 가지며, 이 컨텍스트 내에서 선언된 변수와 함수는 해당 함수 내에서만 유효하기에 함수가 종료되면 그 실행 컨텍스트도 함께 사라지게 된다.

<br>
<br>

### 실행 컨텍스트의 구성요소

- 변수 객체, 스코프 체인, this 의 구성요소로 이루져 있다.

- 변수 객체란 실행 컨텍스트 내에서 사용 되는 변수와 함수 선언을 저장하는 공간을 말한다. 전역 객체가 변수 객체의 역할을 하고, 함수 컨텍스트에서는 활성화 객체가 변수와 매개변수를 관리한다.

- 스코프 체인의 경우 실행 중인 컨텍스트와 외부 렉시컬 환경의 연결을 유지한다. 변수를 참조할 때 현재 컨텍스트에서 찾지 못하면 외부 환경으로 범위를 넓혀가며 변수를 찾는다.

- this 는 실행 컨텍스트에 따라 참조하는 객체가 달라지는데 전역 컨텍스트에서 this는 전역 객체를 가리키며, 함수 컨텍스트에서는 함수 호출 방법에 따라 달라지게 된다.

- 실행 컨텍스트는 이러한 구성 요소를 통해 자바스크립트 코드가 실행되는 동안의 환경을 관리하고, 코드 실행 시 변수의 유효 범위 또는 함수 호출 맥락을 결정 짓는다.

[실행 컨텍스트란 무엇인가?](https://www.youtube.com/watch?v=EWfujNzSUmw)

<br>
<br>

### tanstack-query에서 stale time과 gc time의 차이점에 대해서 설명해주세요

- TanStack Query에서 stale time과 gc time은 데이터를 캐싱하고 관리하는 데 중요한 두 가지 설정이다. 

- stale time은 데이터가 얼마나 오래 "신선한 상태"로 유지 되는지를 정하는 것이고 gc time은 데이터가 오래된 상태가 된 이후에도 캐시에서 얼마동안 유지 될지를 정하는 시간을 말한다.

- 위 말대로 stale time 은 데이터를 초기에 가져온 후 추가적인 네트워크 요청이 일어나지 않고 캐시에 저장 된 데이터를 그대로 사용하게 된다. 5분으로 설정 했다고 할 때 데이터를 가져오고 5분 동안은 데이터가 신선하기 때문에 교체할 필요가 없다고 판단하기에 캐시 된 데이터를 계속 해서 사용한다. stale time 의 기본 값은 '0'

- gc time은 오래된 상태의 데이터를 캐시에 얼마동안 저장할지를 결정하는 시간이다. stale time이 5분이라고 할 때 5분이 지난 후 "오래 된 상태"의 데이터가 되는데 gc time 을 10분으로 설정하였을 때 초기 데이터를 가져온 후 15분 이후에 다시 신선한 데이터를 가져오는 네트워크 요청을 보낸다는 것을 알 수  있다. gc time 의 기본 값은 '5'

- 따라서 별도의 설정을 하지 않은 경우 Tanstack-Query 에서 데이터를 초기에 가져온 후 직후에 데이터가 '오래 된 상태'라고 판단하고 gc time 의 기본 값 만큼 유지 된 후 새로운 데이터를 요청한다는 사실을 알 수 있다. stale time과 gc time 을 통해 불필요한 데이터 요청을 줄이면서 최신 데이터를 가져올 수 있도록 핸들링이 가능하다.

<br>
<br>


### 이벤트 루프에 대해서 설명해주세요.

- 자바스크립트의 이벤트루프는 JS가 싱글 스레드 기반 언어임에도 불구하고 비동기 작업을 가능하게 하는 중요한 메커니즘이다.

- 기본적으로 한 번에 하나의 작업만을 처리하는 JS 이지만 이벤트 루프가 콜 스택, 태스크 큐를 관리하면서 비동기 작업이 완료 되었을 때 그 결과를 처리할 수 있도록 도와준다. 콜 스택이란 현재 실행 중인 코드들이 쌓이는 곳, 태스크 큐는 비동기 작업이 완료되면 그 결과를 대기 시키는 곳이다.

- setTimeout(callback, 0)를 예시로 들 수 있다. 인자로 콜백 함수와 stale time 을 받는 setTimeout과 같은 경우 호출 시 바로 실행 되는 것이 아닌 웹 API에 의해 타이머가 설정 되고, 타이머가 0ms 이후 만료되면서 콜백 함수가 태스크 큐에 추가가 된다. 그 후 콜 스택이 비어있는 시점에서 이벤트 루프는 태스크 큐에 대기중인 결과인 callback을 실행하게 된다.

- setTimeout을 호출하여도 현재 실행 중인 모든 동기 작업들이 완료된 후에야 콜백이 실행되게 된다. setTimeout을 사용하여 코드의 실행을 다음 이벤트루프 사이클로 미루는 것이 가능하다는 것이다.

<br>
<br>

### 태스크 큐의 종류?

- 크게 매크로태스크 큐, 마이크로태스크 큐로 나뉘어진다. 

- 매크로태스크 큐의 경우 setTimeout, setInterval 같은 일반적인 비동기 작업들이 대기하는 큐이고 이 작업은 이벤트 루프가 콜 스택 & 마이크로 태스크 큐의 작업을 모두 처리한 후에 하나씩만 처리한다.

- 마이크로태스크 큐는 Promise.then()과 같이 중요도가 높은 작업들이 대기하는 큐를 말한다. 마이크로태스크 큐는 매크로태스크 큐보다 우선순위가 높기때문에 이벤트 루프는 콜 스택이 비어있는 시점에 매크로태스크를 실행하기 이전에 마이크로태스크 큐에 있는 모든 작업들을 먼저 처리한다.

<br>
<br>

### 리액트의 props와 state에 대해서 설명해주세요.

- props는 부모 컴포넌트가 자식 컴포넌트에 전달하는 데이터를 말한다. props는 읽기 전용이기 떄문에 자식 컴포넌트는 props를 수정할 수 없다.

- props가 자식 컴포넌트에서 변하지 않는 이유는 리액트의 단방향 데이터 흐름 원칙 때문이다(트리 구조). 읽기 전용이기 때문에 전달 된 값이 자식 컴포넌트 내에서 임의로 변경이 될 수 없다. 만약 props가 변경 될 수 있다면 자식 컴포넌트는 독립적으로 동작하지 않게 되고, 재사용이 어려울 수 있다. 불변이 유지 됨으로써 외부입력에 의존하면서 내부적으로 변경하지 않아 재사용성이 높아지고 코드의 캡슐화가 강화된다.

- 이러한 특징으로 인해 컴포넌트 간의 데이터 흐름을 예측 가능하게 만들고, 컴포넌트의 재사용성을 높일 수 있다.

- state는 컴포넌트 내부에서 관리되는 데이터를 말한다. state는 동적으로 변경 될 수 있으며 컴포넌트의 렌더링에 영향을 미칠 수 있다. state를 변경하면 컴포넌트는 다시 렌더링 되며 UI가 업데이트 된다. 주로 사용자의 입력 또는 네트워크 요청의 응답에 따라 변하는 데이터를 관리할 때 사용된다.


<br>
<br>

### 리액트의 Controlled Component와 Uncontrolled Component

- Controlled Component란 리액트의 상태(state)를 통해 입력 값을 제어하는 컴포넌트를 말한다. 입력 요소의 값(value)을 리액트 상태와 동기화 하고 사용자가 입력을 변경할 때마다 onChange 이벤트 핸들러를 통해 상태를 업데이트한다. 

- 예시로 useState를 활용한 input value를 제어하는 상황을 말할 수 있다. value는 리액트의 상태로 관리되며 onChange 이벤트가 발생할 때마다 상태가 업데이트 된다. 

- 주요 장점은 입력값이 리액트의 상태로 관리 되므로 값을 쉽게 검증, 변경할 수 있고 복잡한 폼 로직을 처리하는데에 유리하다는 것.

- Uncontrolled Component는 리액트의 상태가 아닌, DOM 자체가 입력값을 제어하는 방식을 말한다.

- 입력 요소의 값은 DOM에서 직접 관리되며, 리액트는 이를 제어하지 않는다. 이 방식에서는 ref를 사용하여 DOM 요소에 직접 접근해 값을 읽거나 조작할 수 있다.

- input과 관련 된 ref는 useRef를 사용해 생성된 참조 객체로, 입력값을 직접 접근하고 조작할 수 있다. Uncontrolled Component는 상대적으로 간단한 폼이나 초기값이 중요한 상황에서 사용할 수 있다.

<br>
<br>

### 언제 어떤 것을 사용해야 할까?

- ref를 사용하면 DOM을 통해 직접 접근하여 값을 읽어오기때문에, 단순한 입력 필드가 포함된 폼에서 ref를 사용하는 것이 더 간단하고 성능이 좋을 수 있다. 사용자가 제출 버튼을 클릭했을 때만 입력값을 가져오면 되는 경우를 예로 들 수 있다. 만약에 값을 입력할때마다 유효성 검증을 실시간을 해주어야하는 경우에는 Controlled Component를 사용하는 것이 좋다.

<br>
<br>

### 리액트에서 어떤 식으로 성능 최적화를 할 수 있을까?

- 리액트 성능 최적화를 위한 여러가지 방법이 존재하지만 대표적으로 메모이제이션이 존재한다. 

- 리액트의 memo를 사용하여 컴포넌트를 메모이제이션할 수 있다. 이는 컴포넌트의 props가 변경되지 않았을 때, 리렌더링을 방지하여 성능 최적화가 가능하다 특히 렌더링 비용이 큰 컴포넌트에서 유용.

- 또는 useCallback & useMemo도 사용이 가능하다. useCallback의 경우 함수를 메모이제이션하여 불필요한 함수 재생성을 방지, useMemo는 값의 재계산을 방지하여 최적화에 도움을 줄 수 있다. 이를 통해 자식 컴포넌트로 전달되는 함수나 값이 변경되지 않으면 리렌더링을 피할 수 있다.

- 또는 코드스플리팅을 예로 들 수 있는데, 코드 스플리팅은 큰 애플리케이션을 여러 개의 작은 청크로 나누어, 필요한 청크만 로드하게 하여 초기 로드 시간을 줄인다. React.lazy와 Suspense를 사용하여 동적으로 컴포넌트를 로드할 수 있다! 

- 코드 스플리팅은 초기 로딩 시간이 길어지는 경우 사용할 수 있다. 애플리케이션이 커지면, 초기 로딩에 모든 코드를 로드하는 것이 비효율적일 수  있기때문에 초기 로드 시 필요한 핵심 코드만 로드하고, 이후 추가적인 기능은 필요할 때 로드하도록 구성할 수 있다. 또는 라우트별 코드 분할이 필요할 때 SPA에서는 각 페이지가 별도의 기능과 UI를 가지므로, 라우트별로 필요한 코드만 분리하여 로드할 수 있다. 이 방식은 리액트의 React.lazy와 Suspense를 사용하여 라우트별 컴포넌트를 동적으로 불러올 때 유용!

<br>
<br>

### 브라우저의 렌더링 파이프란 무엇인가?

- 브라우저가 웹 페이지를 화면에 표시하기 위해 거치는 과정을 브라우저 렌더링 파이프라인이라고 하며 이 과정은 크게 5단계로 나눌 수 있다.

1. 가장 먼저 DOM 생성이다. 브라우저가 HTML 파일을 받으면, 이 파일을 바이트(byte) 단위로 읽기 시작한다. 브라우저의 HTML 파서(Parser)는 이 바이트들을 문자(character)로 변환하고, 이 문자들을 다시 HTML 토큰으로 변환! 이 HTML 토큰들은 각각의 태그와 그 안에 포함된 텍스트, 속성 등을 의미하게 된다.  이후 HTML토큰을 기반으로 DOM트리를 생성한다. HTML 문서 구조를 트리 형태(노드 => 정점과 간선)로 표현한 것으로 각 태그가 노드가 되어 부모 - 자식 관계를 형성.

2. CSSOM(Cascading Style Sheet Object Model) 생성을 한다. CSS 파일을 파싱하고 이 역시 바이트로 전송 후 문자로 변환 한 뒤 CSS 규칙을 만든다. CSS 규칙의 경우 선택자(selector) & 선언(declaration)으로 구성되는데, 선택자는 스타일을 적용할 HTML 요소를 정의하고 선언은 적용할 스타일을 정의한다. 브라우저에서는 이 CSS규칙을 기반으로 CSSOM 트리를 생성 => 이는 DOM과 유사하게 트리 구조를 가지며 각 노드는 해당 노드에 적용되는 스타일 정보를 포함한다.

3. 렌더 트리를 생성한다. 브라우저는 DOM과 CSSOM을 결합하여 렌더 트리를 생성하는데 이는 화면에 실제로 표시될 요소들로만 구성이 된다.({ display: none } 과 같은 속성이 있는 요소는 렌더트리에 포함이 되지 않음) 렌더 트리의 각 노드는 DOM 트리의 요소와 연결되며, CSSOM 트리에서 해당 요소에 적용된 스타일 정보를 포함한다. (쉽게 말해서 HTML 문서의 구조 + 각 요소의 스타일 정보를 모두 포함한 트리)

4. 렌더 트리 생성 후 브라우저는 이 트리를 사용해 각 요소의 정확환 위치, 크기를 계산하는데 이 과정을 레이아웃 이라고한다. 이 계산은 화면의 뷰포트(viewport) 크기와 같은 정보에 의존한다. 예를 들어 화면 크기가 변경 될 시 브라우저는 레이아웃 과정을 다시 수행해야한다. => 이 과정을 리플로우(Reflow)라고 하는데 성능에 영향을 끼칠 수 있으므로 이를 최소화 하는 것이 중요하다.

5. 다음으로는 페인팅 과정을 거친다. 레이아웃의 계산이 완료되면 브라우저는 각 요소를 실제로 화면에 표시하는 작업을 거치는데 이를 페인팅이라고 한다. 이 단계에서는 텍스트, 색상, 그림자, 이미지 등 모든 시각적 요소가 화면에 그려진다. 복잡한 그래픽, 애니메이션이 포함된 경우 페인트 작업이 많아져 성능이 저하될 수 있음에 유의하자.

6. 마지막으로 컴포지팅이 있다. 브라우저는 화면에 그려질 요소들을 각각의 레이어 층으로 분리하고 이 레이어들을 결합하여 최종 화면을 구성한다. 이 과정에서는 GPU를 활용하여 각 레이어를 빠르게 합성한다. transform과 opacity와 같은 속성은 레이아웃이나 페인트 과정을 거치지 않고 이 컴포지팅 단계에서만 처리가 된다. 덕분에 이러한 속성을 사용하는 애니메이션은 더 부드럽고 빠르게 실행이 가능하다. 

<br>
<br>

### www.google.com 을 입력하면 무슨 일이 일어나는가? 

- 가장 먼저 DNS(Domain Name Service)조회가 이루어진다. 브라우저는 이 도메인 이름을 IP 주소로 변환해야 한다. 이 과정을 DNS 조회(DNS Lookup => nslookup google.com 명령어)하고 하며 브라우저는 캐시된 DNS 기록을 먼저 확인하고 없다면 로컬 DNS 서버에 요청하여 www.google.com에 해당하는 IP 주소를 얻는다.

- 그 다음으로 TCP 연결 수립을 하는데 IP주소가 확인되면 브라우저는 서버와 TCP 연결을 수립한다. TCP는 데이터를 신뢰성 있게 전달하기 위한 프로토콜로써 이 과정에서 브라우저는 서버와 3-way handShake를 수행 한다. 브라우저가 Sync 패킷을 보내고 서버가 Sync - ACK 패킷을 보내면 다시 브라우저가 ACK 패킷을 보내는 과정.

- HTTP 요청을 한다. TCP 연결이 수립되면 브라우저는 HTTP 또는 HTTPS 요청을 보내는데 이 요청은 "GET/HTTP/1.1" 같은 형식으로 웹 페이지를 요청하는 메시지를 말한다. HTTPS를 사용할 경우 이 단계에서 SSL/TLS 핸드셰이크도 수행 된다. 이 과정에서 브라우저와 서버가 암호화된 연결을 설정하기 위해 보안 인증서를 교환하고 암호화 키를 협상한다.

- 서버의 응답을 받는다. 서버는 요청을 받고, 해당 리소스(HTML,CSS,JS, 이미지 등)를 브라우저에게 응답으로 보내고 이 응답은 HTTP 응답 코드(200 OK등의 status code)와 함께 전달 된다.

- 마지막으로 받은 리소스들을 바탕으로 브라우저 렌더링 파이프라인을 진행한다. DOM, CSSOM 생성 및 렌더 트리를 구성한 뒤 레이아웃과 페인트 단계를 통해 웹 페이지가 화면에 표시된다.

<br>
<br>

### 리액트의 Strict Mode

- StrictMode는 주로 개발 중에 발생할 수 있는 잠재적인 문제를 사전에 감지하고 예방하기 위해 사용되는데 몇 가지 주요 목적을 가지고 있다.

- 첫 째로 오래된 라이프사이클 메서드와 비권장 API의 사용을 감지한다. 예를 들어 componentWillMount, componentWillReceiveProps 와 같은 메서드는 더 이상 사용이 권장 되지 않는데, StrictMode는 이러한 메서드들이 코드에 포함 된 경우 경고를 표시해준다. 이를 통해 개발자가 최신 React API를 사용하여 보다 안정적이고 효율적인 코드를 작성할 수 있도록 돕는다.

- 또한 의도치 않은 부수 효과를 방지한다. 리액트는 컴포넌트의 렌더링이 예측 가능하고 순수하게 이루어지기를 기대하는데 StrictMode는 이를 검증하기 위해 useEffect, useState 등 일부 훅이나 메서드를 두 번씩 실행 시킨다. 이렇게 두 번 실행이 되는 이유는, 동일한 결과가 나오는지를 확인함으로써 컴포넌트가 사이드 이펙트를 일으키지 않고 순수하게 동작하는지를 검사하기 위함이다.

- 예기치 않은 동작, 버그를 사전에 방지하기 위해 위의 검증은 중요하다. 개발환경에서 두 번씩 실행 하였으나 문제가 발생하지 않는다면 프로덕션에서도 안전하게 실행 된다는 신호라는 것을 알 수 있기 때문이다. 실제 프로덕션에서는 한 번만 실행 되기 때문에 성능에는 영향을 끼치지 않는다. 

<br>
<br>

### 리액트의 render phase & commit phase

- 리액트의 렌더링 과정은 크게 두가지로 나뉘는데 바로 render phase & commit phase 이다.

- render phase는 리액트가 변화된 상태나 props에 따라 어떤 UI가 변경 되어야 하는지를 결정하는 단계를 말한다. 이 과정에서는 실제로 DOM을 업데이트하지 않고 변경사항을 가상 DOM에서 계산하여 비교한다, 순수하게 계산을 하는 과정이기 때문에 성능에 영향을 주지 않도록 중단되거나 다시 실행 될 수 있으며, 18에서 도입 된 Concurrent Mode를 통해 비동기적으로 처리될 수도 있다.

- commit phase는 실제로 변화된 UI를 DOM에 반영하는 단계이다. 이때 리액트는 가상 DOM에서 계산 된 결과를 실제 DOM에 적용하고 변화된 UI를 브라우저에 렌더링한다. 이 과정에서 useEffect와 같은 사이트 이펙트가 발생하는 훅들이 실행된다.

- 요약하자면 render phase는 변화 된 UI를 결정하는 계산 과정, commit phase는 계산 된 결과를 실제로 반영하는 단계를 말한다.