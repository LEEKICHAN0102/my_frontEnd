# 면접 질문

- 매일메일의 면접 예상 질문과 답변을 정리한 MD 형식의 문서

<br>

### 클로저에 대해 설명해주세요

- 클로저는 함수가 선언될 때의 스코프를 기억하여, 함수가 생성된 이후에도 그 스코프에 접근할 수 있는 기능을 말합니다. 비유하자면, 함수가 자신이 생성된 환경을 '기억'하는 것이라고 할 수 있습니다. 클로저는 자바스크립트의 함수가 일급 객체라는 특성과 렉시컬 스코프의 조합으로 만들어집니다.

```
// 클로저의 예시

function outerFunction(outerVariable) {
  return function innerFunction(innerVariable) {
    console.log('Outer Variable: ' + outerVariable);
    console.log('Inner Variable: ' + innerVariable);
  };
}

const newFunction = outerFunction('outside');
newFunction('inside');
```

- innerFunction은 outerFunction의 내부에 정의 되어있다. innerFunction은 자신이 생성된 스코프, 즉 outerFunction의 스코프를 기억하고, outerFunction의 호출이 완료된 이후에도 그 스코프에 접근이 가능하다. => innerFunction은 outerVariable에도 접근이 가능!

- newFunction은 outerFunction에 'outside' 라는 인자넣은 함수를 초기화 하였음. outerVariable === 'outside' 가 되는 것은 당연한 결과. 이때 newFunction을 'inside' 인자를 넣은 후 호출하면 return 값에 해당 되는 인자는 innerFunction에 해당하게 됨. 자신이 생성 된 스코프를 기억하고 있기 때문에 outerFunction 호출 이후에도 접근이 가능하기떄문!

- 클로저는 데이터 은닉,  비동기 작업, 모듈 패턴 구현 등 사용이 가능하다. 변수와 함수의 접근 범위를 제어하고 특정 데이터와 상태를 유지하기 용이하기에 위 작업에 도움이 될 수 있다.

<br>
<br>

### reflow와 repaint의 차이점에 대해서 설명해주세요.

- 우선 reflow와 repaint 가 무엇인지 알아볼 필요가 있다. reflow는 브라우저가 페이지의 레이아웃을 다시 계산하는 과정을 말한다. DOM, CSS 스타일 등이 변하게 되면 브라우저는 각 요소가 화면에 어떻게 배치될지 다시 계산하기에 자식 요소와 관련된 부모 요소까지 영향을 끼치기 때문에 비용이 많이 드는 작업이다.

- repaint는 요소의 모양이나 스타일이 변경 될 떄 발생한다. 레이아웃은 동일하나 색상, 배경 등 스타일이 변경 되는 경우를 말한다(background-color 등). reflow보다는 비용이 덜 들지만 성능에 영향을 끼칠 수는 있다.

- 쉽게 비유해서 reflow가 집을 다시 짓는 과정이라고 하면 repaint는 말그대로 페인트칠만 다시하는 것이라고 생각할 수 있다. 레이아웃을 처음부터 계산 하는 과정 <=> 계산 결과를 화면에 다시 그리는 과정.

- reflow와 repaint를 어떻게 관리하는 것이 성능 최적화에 도움을 줄 수있을까?

1. reflow를 유발하는 CSS 속성 사용의 최소화가 방법이 될 수 있다. width, height, margin, padding 등의 속성은 요소의 레이아웃을 다시 계산하기 떄문에 reflow를 일으키기에 CSS 스타일을 설정해 초기 로드시에만 이루어지고 이후에는 변경되지 않도록 하는것이 BEST!

2. CSS 애니메이션의 최적화 방법이 있다. 애니메이션 transform & opacity 속성만을 사용하는 것이 성능에 유리하다. 이 둘의 경우 GPU 가속을 사용할 수 있어 reflow 가 아닌 repaint만 발생 시키기에 자원을 적게 사용이 가능하다.

<br>
<br>

### 실행 컨텍스트에 대해서 설명해주세요.

- 실행 컨텍스트란 자바스크립트에서 코드가 실행되는 환경을 의미한다. 자바스크립트 엔진이 코드를 실행할 때, 그 코드가 실행될 때의 환경을 정의하고 관리하기 위해 존재하는 것이 바로 실행 컨텍스트.

- 이 실행 컨텍스트는 크게 전역 실행 컨텍스트, 함수 실행 컨텍스트로 나뉘어지는데 전역 실행 컨텍스트의 경우 자바스크립트가 처음 실행될 떄 생성된다. 프로그램이 종료될 때 까지 유지되며, 전역에서 선언된 변수와 함수가 모두 포함되며 프로그램 내 어디서든 접근이 가능하다는 특징이 있다. JS 는 싱글 스레드이기 때문에 전역 실행 컨텍스트는 1개만 존재한다.

- 함수 실행 컨텍스트는 함수가 호출될 때마다 생성 되는 컨텍스트를 의미한다. 각 함수는 자신만의 실행 컨텍스트를 가지며, 이 컨텍스트 내에서 선언된 변수와 함수는 해당 함수 내에서만 유효하기에 함수가 종료되면 그 실행 컨텍스트도 함께 사라지게 된다.

<br>
<br>

### 실행 컨텍스트의 구성요소

- 변수 객체, 스코프 체인, this 의 구성요소로 이루져 있다.

- 변수 객체란 실행 컨텍스트 내에서 사용 되는 변수와 함수 선언을 저장하는 공간을 말한다. 전역 객체가 변수 객체의 역할을 하고, 함수 컨텍스트에서는 활성화 객체가 변수와 매개변수를 관리한다.

- 스코프 체인의 경우 실행 중인 컨텍스트와 외부 렉시컬 환경의 연결을 유지한다. 변수를 참조할 때 현재 컨텍스트에서 찾지 못하면 외부 환경으로 범위를 넓혀가며 변수를 찾는다.

- this 는 실행 컨텍스트에 따라 참조하는 객체가 달라지는데 전역 컨텍스트에서 this는 전역 객체를 가리키며, 함수 컨텍스트에서는 함수 호출 방법에 따라 달라지게 된다.

- 실행 컨텍스트는 이러한 구성 요소를 통해 자바스크립트 코드가 실행되는 동안의 환경을 관리하고, 코드 실행 시 변수의 유효 범위 또는 함수 호출 맥락을 결정 짓는다.

[실행 컨텍스트란 무엇인가?](https://www.youtube.com/watch?v=EWfujNzSUmw)

<br>
<br>

### tanstack-query에서 stale time과 gc time의 차이점에 대해서 설명해주세요

- TanStack Query에서 stale time과 gc time은 데이터를 캐싱하고 관리하는 데 중요한 두 가지 설정이다. 

- stale time은 데이터가 얼마나 오래 "신선한 상태"로 유지 되는지를 정하는 것이고 gc time은 데이터가 오래된 상태가 된 이후에도 캐시에서 얼마동안 유지 될지를 정하는 시간을 말한다.

- 위 말대로 stale time 은 데이터를 초기에 가져온 후 추가적인 네트워크 요청이 일어나지 않고 캐시에 저장 된 데이터를 그대로 사용하게 된다. 5분으로 설정 했다고 할 때 데이터를 가져오고 5분 동안은 데이터가 신선하기 때문에 교체할 필요가 없다고 판단하기에 캐시 된 데이터를 계속 해서 사용한다. stale time 의 기본 값은 '0'

- gc time은 오래된 상태의 데이터를 캐시에 얼마동안 저장할지를 결정하는 시간이다. stale time이 5분이라고 할 때 5분이 지난 후 "오래 된 상태"의 데이터가 되는데 gc time 을 10분으로 설정하였을 때 초기 데이터를 가져온 후 15분 이후에 다시 신선한 데이터를 가져오는 네트워크 요청을 보낸다는 것을 알 수  있다. gc time 의 기본 값은 '5'

- 따라서 별도의 설정을 하지 않은 경우 Tanstack-Query 에서 데이터를 초기에 가져온 후 직후에 데이터가 '오래 된 상태'라고 판단하고 gc time 의 기본 값 만큼 유지 된 후 새로운 데이터를 요청한다는 사실을 알 수 있다. stale time과 gc time 을 통해 불필요한 데이터 요청을 줄이면서 최신 데이터를 가져올 수 있도록 핸들링이 가능하다.

<br>
<br>


### 이벤트 루프에 대해서 설명해주세요.

- 자바스크립트의 이벤트루프는 JS가 싱글 스레드 기반 언어임에도 불구하고 비동기 작업을 가능하게 하는 중요한 메커니즘이다.

- 기본적으로 한 번에 하나의 작업만을 처리하는 JS 이지만 이벤트 루프가 콜 스택, 태스크 큐를 관리하면서 비동기 작업이 완료 되었을 때 그 결과를 처리할 수 있도록 도와준다. 콜 스택이란 현재 실행 중인 코드들이 쌓이는 곳, 태스크 큐는 비동기 작업이 완료되면 그 결과를 대기 시키는 곳이다.

- setTimeout(callback, 0)를 예시로 들 수 있다. 인자로 콜백 함수와 stale time 을 받는 setTimeout과 같은 경우 호출 시 바로 실행 되는 것이 아닌 웹 API에 의해 타이머가 설정 되고, 타이머가 0ms 이후 만료되면서 콜백 함수가 태스크 큐에 추가가 된다. 그 후 콜 스택이 비어있는 시점에서 이벤트 루프는 태스크 큐에 대기중인 결과인 callback을 실행하게 된다.

- setTimeout을 호출하여도 현재 실행 중인 모든 동기 작업들이 완료된 후에야 콜백이 실행되게 된다. setTimeout을 사용하여 코드의 실행을 다음 이벤트루프 사이클로 미루는 것이 가능하다는 것이다.

<br>
<br>

### 태스크 큐의 종류?

- 크게 매크로태스크 큐, 마이크로태스크 큐로 나뉘어진다. 

- 매크로태스크 큐의 경우 setTimeout, setInterval 같은 일반적인 비동기 작업들이 대기하는 큐이고 이 작업은 이벤트 루프가 콜 스택 & 마이크로 태스크 큐의 작업을 모두 처리한 후에 하나씩만 처리한다.

- 마이크로태스크 큐는 Promise.then()과 같이 중요도가 높은 작업들이 대기하는 큐를 말한다. 마이크로태스크 큐는 매크로태스크 큐보다 우선순위가 높기때문에 이벤트 루프는 콜 스택이 비어있는 시점에 매크로태스크를 실행하기 이전에 마이크로태스크 큐에 있는 모든 작업들을 먼저 처리한다.

<br>
<br>

### 리액트의 props와 state에 대해서 설명해주세요.

- props는 부모 컴포넌트가 자식 컴포넌트에 전달하는 데이터를 말한다. props는 읽기 전용이기 떄문에 자식 컴포넌트는 props를 수정할 수 없다.

- props가 자식 컴포넌트에서 변하지 않는 이유는 리액트의 단방향 데이터 흐름 원칙 때문이다(트리 구조). 읽기 전용이기 때문에 전달 된 값이 자식 컴포넌트 내에서 임의로 변경이 될 수 없다. 만약 props가 변경 될 수 있다면 자식 컴포넌트는 독립적으로 동작하지 않게 되고, 재사용이 어려울 수 있다. 불변이 유지 됨으로써 외부입력에 의존하면서 내부적으로 변경하지 않아 재사용성이 높아지고 코드의 캡슐화가 강화된다.

- 이러한 특징으로 인해 컴포넌트 간의 데이터 흐름을 예측 가능하게 만들고, 컴포넌트의 재사용성을 높일 수 있다.

- state는 컴포넌트 내부에서 관리되는 데이터를 말한다. state는 동적으로 변경 될 수 있으며 컴포넌트의 렌더링에 영향을 미칠 수 있다. state를 변경하면 컴포넌트는 다시 렌더링 되며 UI가 업데이트 된다. 주로 사용자의 입력 또는 네트워크 요청의 응답에 따라 변하는 데이터를 관리할 때 사용된다.


<br>
<br>

### 리액트의 Controlled Component와 Uncontrolled Component

- Controlled Component란 리액트의 상태(state)를 통해 입력 값을 제어하는 컴포넌트를 말한다. 입력 요소의 값(value)을 리액트 상태와 동기화 하고 사용자가 입력을 변경할 때마다 onChange 이벤트 핸들러를 통해 상태를 업데이트한다. 

- 예시로 useState를 활용한 input value를 제어하는 상황을 말할 수 있다. value는 리액트의 상태로 관리되며 onChange 이벤트가 발생할 때마다 상태가 업데이트 된다. 

- 주요 장점은 입력값이 리액트의 상태로 관리 되므로 값을 쉽게 검증, 변경할 수 있고 복잡한 폼 로직을 처리하는데에 유리하다는 것.

- Uncontrolled Component는 리액트의 상태가 아닌, DOM 자체가 입력값을 제어하는 방식을 말한다.

- 입력 요소의 값은 DOM에서 직접 관리되며, 리액트는 이를 제어하지 않는다. 이 방식에서는 ref를 사용하여 DOM 요소에 직접 접근해 값을 읽거나 조작할 수 있다.

- input과 관련 된 ref는 useRef를 사용해 생성된 참조 객체로, 입력값을 직접 접근하고 조작할 수 있다. Uncontrolled Component는 상대적으로 간단한 폼이나 초기값이 중요한 상황에서 사용할 수 있다.

<br>
<br>

### 언제 어떤 것을 사용해야 할까?

- ref를 사용하면 DOM을 통해 직접 접근하여 값을 읽어오기때문에, 단순한 입력 필드가 포함된 폼에서 ref를 사용하는 것이 더 간단하고 성능이 좋을 수 있다. 사용자가 제출 버튼을 클릭했을 때만 입력값을 가져오면 되는 경우를 예로 들 수 있다.

만약에 값을 입력할때마다 유효성 검증을 실시간을 해주어야하는 경우에는 Controlled Component를 사용하는 것이 좋다.
