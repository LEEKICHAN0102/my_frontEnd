# 프론트엔드 전반

- 프론트엔드는 웹 및 앱 사용자가 직접 상호 작용하는 부분을 담당하는 개발 분야입니다. 이는 웹사이트나 애플리케이션의 사용자 인터페이스(UI)와 사용자 경험(UX)을 개발하는 것을 포함합니다.

- 프론트엔드 개발은 사용자가 웹사이트나 앱을 쉽게 사용할 수 있도록 인터페이스를 설계하고 구현하는 것을 중점으로 합니다. 이는 사용자가 버튼을 클릭하거나 폼을 작성할 때 발생하는 상호작용부터, 웹 페이지의 레이아웃과 디자인까지 다양한 측면을 다룹니다.

<br>

## 목차
  - [브라우저(Browser)](#브라우저(Browser))
  - [렌더링(rendering)](#렌더링(rendering))
  - [브라우저의 렌더링 과정](#브라우저의-렌더링-과정)
  - [Webpack, Babel, Polyfill](#Webpack,-Babel,-Polyfill)
  - [ESLint, Prettier](#ESLint,-Prettier)
  - [SPA(Single Page Application) & MPA(Multiple Page Application)](#SPA(Single-Page-Application)-&-MPA(Multiple-Page-Application))
  - [CSR(Client-Side Rendering) & SSR(Server-Side Rendering)](#CSR(Client-Side-Rendering)-&-SSR(Server-Side-Rendering))
  - [CORS(Cross-Origin Resource Sharing)](#CORS(Cross-Origin-Resource-Sharing))
  - [쿠키, 세션, 웹스토리지](#쿠키,-세션,-웹스토리지)
  - [로그인 시 쿠키 & 세션 인증 방식](#로그인-시-쿠키-&-세션-인증-방식)
  - [토큰 기반 인증 방식](#토큰-기반-인증-방식)
  - [JWT(JSON Web Token)](#JWT(JSON-Web-Token))
  - [쿠키 & 세션 vs JWT](#쿠키-&-세션-vs-JWT)
  - [크로스 브라우징(Cross Browsing)](#크로스-브라우징(Cross-Browsing))
  - [웹 사이트 성능 최적화](#웹-사이트-성능-최적화)
  - [객체 지향 프로그래밍(Object-Oriented Programming, OOP)](#객체-지향-프로그래밍(Object-Oriented-Programming,-OOP))
  - [JavaScript 객체 지향](#JavaScript-객체-지향)
  - [REST(Representational State Transfer) API](#REST(Representational-State-Transfer)-API)
  - [SEO(Search Engine Optimization)](#SEO(Search-Engine-Optimization))

<br>

### 브라우저(Browser)

- 브라우저는 인터넷을 통해 웹 페이지를 검색하고 보는 데 사용되는 소프트웨어 응용 프로그램입니다. 일반적으로 웹 브라우저는 사용자가 웹 페이지의 주소를 입력하거나 하이퍼링크를 클릭하여 웹 페이지를 요청하고, 해당 웹 페이지를 표시하는 역할을 합니다.

- 웹 브라우저는 웹 페이지의 HTML, CSS, JavaScript 등의 소스 코드를 해석하고, 사용자가 이를 시각적으로 볼 수 있는 형태로 렌더링합니다. 이러한 기능을 통해 사용자는 웹을 통해 다양한 정보에 접근하고, 웹 사이트와 상호 작용할 수 있습니다.

- 대표적인 웹 브라우저로는 구글 크롬, 모질라 파이어폭스, 애플 사파리, 마이크로소프트 엣지, 오페라 등이 있습니다. 각 브라우저는 고유한 기능과 특징을 가지고 있으며, 웹 표준을 준수하여 웹 페이지를 렌더링하는 방식이 조금씩 다를 수 있습니다.

<br>

### 렌더링(rendering)

- 렌더링(rendering)은 컴퓨터 그래픽스에서 시각적인 결과물을 생성하는 과정을 의미합니다. 웹 개발에서는 브라우저가 HTML, CSS, JavaScript 등의 웹 페이지 자원을 해석하고 이를 화면에 표시하는 과정을 렌더링이라고 합니다.

<br>

### 브라우저의 렌더링 과정

- 브라우저 렌더링 과정은 웹 페이지를 브라우저 화면에 표시하기 위한 단계적인 프로세스입니다. 일반적으로 다음과 같은 단계로 구성됩니다.

<img src="../../Images/Frontend/browserrendering.png" />

1. HTML 파싱(HTML Parsing)

- 브라우저는 웹 페이지의 HTML 문서를 요청하고 받습니다. HTML 파서가 HTML 문서를 읽고, DOM(Document Object Model) 트리를 생성합니다. DOM은 웹 페이지의 구조를 표현하는 트리 구조로, 각 요소(element)는 노드(node)로 표현됩니다.

2. CSS 파싱(CSS Parsing)

- 브라우저는 스타일 시트(CSS)를 요청하고 받습니다. CSS 파서가 CSS 파일을 읽고, 스타일 규칙을 파싱하여 스타일 규칙 트리를 생성합니다. 이 과정에서 스타일 시트의 규칙은 해당하는 DOM 요소에 적용됩니다.

3. 렌더 트리 구축(Render Tree Construction)

- DOM 트리와 스타일 규칙 트리를 결합하여 렌더 트리(render tree)를 생성합니다. 렌더 트리는 화면에 표시될 요소들의 구조와 스타일 정보를 포함합니다. 하지만, 렌더 트리에는 실제로 화면에 표시되지 않는 요소들(예: "head tag" 또는 display: none으로 숨겨진 요소)은 포함되지 않습니다.

4. 레이아웃(Layout)

- 브라우저는 렌더 트리를 사용하여 각 요소의 크기와 위치를 계산합니다. 이 과정에서 요소의 크기, 위치, 여백, 패딩 등이 결정됩니다.

5. 페인팅(Painting)

- 브라우저는 화면에 표시할 최종 픽셀을 생성합니다.각 요소의 스타일에 따라 색상, 배경, 테두리 등이 그려집니다.

6. 리플로(Ripple)

- 사용자의 입력이나 화면의 변경에 따라 필요한 경우, 렌더링 과정을 다시 실행하여 변경된 내용을 반영합니다.

<br>

### Webpack, Babel, Polyfill

- 웹 개발에서 현대적인 기술 스택을 구성하고, 다양한 브라우저 및 환경에서의 호환성을 유지하는 데에 필수적으로 사용되는 도구들 입니다.

1. Webpack

- 웹팩(Webpack)은 모듈 번들러(module bundler)로, 웹 애플리케이션을 구성하는 자원(HTML, CSS, JavaScript, 이미지 등)을 모두 모듈로 보고 이를 하나의 번들(bundle)로 묶어주는 도구입니다.

- 웹팩은 여러 모듈 간의 의존성을 파악하여 필요한 파일들을 로드하고 번들링합니다. 이를 통해 네트워크 요청 수를 줄이고, 웹 애플리케이션의 로딩 속도를 개선할 수 있습니다.

- 또한, 웹팩은 다양한 로더(loader)와 플러그인(plugin)을 제공하여 JavaScript 파일 외에도 CSS, 이미지, 폰트 등 다양한 자원들을 처리할 수 있습니다.

2. Babel

- 바벨(Babel)은 JavaScript 컴파일러로, 최신 버전의 JavaScript 문법을 지원하지 않는 환경에서도 최신 문법을 사용할 수 있도록 변환해주는 역할을 합니다.

- 주로 ES6(ECMAScript 2015) 이상의 문법을 사용하여 개발할 때, 바벨을 사용하여 이를 하위 버전의 JavaScript로 변환하여 호환성을 확보할 수 있습니다. 또한, 바벨은 JSX 같은 확장 문법을 일반 JavaScript로 변환하는 데에도 사용됩니다.

3. Polyfill

- 폴리필(Polyfill)은 웹 개발에서 특정 기능을 지원하지 않는 구형 브라우저에서 해당 기능을 구현하기 위한 코드 조각을 의미합니다. 예를 들어, 최신 버전의 JavaScript API나 CSS 속성을 구현하지 않는 구형 브라우저를 위해 폴리필을 사용하여 해당 기능을 지원합니다.

- 폴리필은 일반적으로 바벨과 함께 사용되며, 바벨은 코드를 하위 버전의 JavaScript로 변환하고, 필요한 폴리필을 적용하여 최종적으로 호환성을 확보합니다.

<br>

### ESLint, Prettier

- ESLint와 Prettier는 모두 JavaScript 코드를 작성하고 유지하는 데 도움을 주는 도구입니다.

1. ESLint

- ESLint는 JavaScript 코드의 문법, 스타일, 코드 품질 등을 검사하고 검증하는 도구입니다. 주로 코드 스타일의 일관성을 유지하고 버그를 사전에 발견하여 코드 품질을 향상시키는 데 사용됩니다.

- ESLint는 다양한 규칙을 포함하고 있으며, 이러한 규칙은 개발 팀이나 프로젝트의 요구에 맞게 구성할 수 있습니다. 또한, ESLint는 플러그인(plugin) 시스템을 통해 사용자 정의 규칙을 추가하거나 확장할 수 있습니다.

- 개발자가 코드를 작성하면 ESLint가 지정된 규칙을 기반으로 코드를 분석하고, 코드 스타일 문제나 잠재적인 오류를 식별하여 보고합니다.

2. Prettier

- Prettier는 코드 포맷터(code formatter)로, 코드의 서식을 일관되게 정리하고 자동으로 포맷팅해주는 역할을 합니다. 주로 코드베이스 내의 서로 다른 개발자들이 작성한 코드를 통일된 형식으로 정리하고, 일관된 스타일을 유지하는 데 사용됩니다.

- Prettier는 일관된 스타일을 유지하기 위해 사용자가 정의한 설정 파일에 따라 코드를 자동으로 재구성합니다. 코드 작성 시 개발자가 수동으로 서식을 조정할 필요가 없으며, Prettier가 코드를 자동으로 포맷팅하여 일관된 스타일을 유지합니다.

- 일반적으로 ESLint와 함께 사용되어, 코드의 스타일 검사와 코드 포맷팅을 모두 수행하여 코드의 가독성과 유지보수성을 향상시킵니다.

<br>

- ESLint와 Prettier는 모두 JavaScript 코드의 품질을 향상시키고 유지보수를 용이하게 만들어주는 데 중요한 역할을 합니다. 현대적인 웹 개발 프로젝트에서는 보통 이 두 가지 도구를 함께 사용하여 코드의 품질과 일관성을 유지하고 개발자들 간의 협업을 촉진합니다.

<br>

### SPA(Single Page Application) & MPA(Multiple Page Application)

- SPA(Single Page Application)와 MPA(Multiple Page Application)는 웹 애플리케이션의 구조를 나타내는 두 가지 주요한 패턴입니다.

1. SPA (Single Page Application)

- SPA는 하나의 HTML 페이지로 구성된 애플리케이션입니다. 초기에 한 번만 페이지를 로드하고, 이후에는 페이지 간의 전환을 위해 JavaScript를 사용하여 필요한 데이터만 동적으로 로드합니다.

- SPA는 클라이언트 측에서 모든 UI와 데이터 처리를 담당하며, 서버는 단순히 데이터를 제공하는 역할만 수행합니다. 주로 React, Angular, Vue.js와 같은 프론트엔드 프레임워크나 라이브러리를 사용하여 개발됩니다.

- 사용자 경험을 향상시키고 애플리케이션의 성능을 개선할 수 있으며, SPA는 빠른 페이지 로드와 부드러운 전환 효과를 제공합니다.

2. MPA (Multiple Page Application)

- MPA는 여러 개의 HTML 페이지로 구성된 애플리케이션입니다. 각 페이지는 별도의 HTML 문서를 가지고 있으며, 전통적인 방식으로 서버 측에서 페이지를 렌더링하여 전달합니다.

- 사용자가 애플리케이션 내에서 다른 페이지로 이동할 때마다 새로운 HTML 문서가 서버로부터 로드됩니다. MPA는 전통적인 웹 애플리케이션의 구조를 따르며, 서버 측에서 전체 페이지를 렌더링하는 방식으로 동작합니다.

- 서버 측에서 HTML을 생성하고 전송하는 방식이므로 SEO(Search Engine Optimization)에 유리할 수 있습니다.

<br>

- SPA와 MPA는 각각의 장단점을 가지고 있으며, 프로젝트의 요구사항과 목표에 따라 선택되어야 합니다. SPA는 사용자 경험과 성능을 개선할 수 있지만 초기 로딩 시간이 오래 걸릴 수 있습니다. 

- 반면에 MPA는 SEO에 유리하고 서버 측에서 렌더링되기 때문에 초기 로딩 시간이 빠를 수 있으나 전체적인 사용자 경험이 떨어질 수 있습니다.

<br>

### CSR(Client-Side Rendering) & SSR(Server-Side Rendering)

- CSR(Client-Side Rendering)과 SSR(Server-Side Rendering)은 웹 애플리케이션의 페이지 렌더링 방식에 대한 두 가지 주요한 접근 방식입니다.

1. CSR (Client-Side Rendering)

- CSR은 클라이언트 측에서 페이지 렌더링을 처리하는 방식입니다. 초기 요청 시 서버는 HTML과 필요한 자원(JavaScript, CSS)을 제공하고, 클라이언트는 이를 받아 브라우저에서 실행합니다.

- 이후에는 JavaScript가 서버 API를 통해 데이터를 가져와 브라우저에서 동적으로 UI를 업데이트합니다. 주로 React, Vue.js, Angular와 같은 프론트엔드 프레임워크와 라이브러리를 사용하여 개발됩니다.

2. SSR (Server-Side Rendering)

- SSR은 서버 측에서 페이지 렌더링을 처리하는 방식입니다. 초기 요청 시 서버는 요청된 페이지의 HTML을 생성하여 클라이언트에게 전송합니다.

- 서버는 데이터베이스 또는 외부 API와 통신하여 필요한 데이터를 가져와 HTML에 포함시키고, 완전한 HTML 페이지를 생성합니다. 클라이언트는 받은 HTML을 브라우저에 표시하고, 이후에는 클라이언트 측에서 추가적인 동적 렌더링이 발생할 수 있습니다.

- 서버 사이드 렌더링(SSR)을 지원하는 React 프로젝트를 개발할 때 주로 Next.js와 같은 프레임워크를 사용합니다. Next.js는 React 기반의 서버 사이드 렌더링(SSR) 및 정적 사이트 생성(SSG)을 지원하는 프레임워크입니다.

- Next.js를 사용하여 개발된 React 애플리케이션은 서버 측에서 초기 HTML을 생성하여 클라이언트에게 전송하고, 이후에는 클라이언트 측에서 추가적인 동적 렌더링을 처리합니다. 이를 통해 초기 로딩 속도가 빠르고 SEO에도 유리한 애플리케이션을 개발할 수 있습니다.


<br>

- CSR과 SSR은 각각의 장단점을 가지고 있습니다. CSR은 초기 로딩 속도가 빠르고 클라이언트 측에서 동적으로 UI를 업데이트할 수 있으나 SEO에 불리할 수 있습니다. 

- 반면에 SSR은 초기 로딩 속도가 느릴 수 있지만 검색 엔진 최적화(SEO)에 유리하고 사용자에게 초기 렌더링된 페이지를 제공할 수 있습니다. 선택은 프로젝트의 요구 사항과 목표에 따라 달라집니다.

<br>

### CORS(Cross-Origin Resource Sharing)

- CORS(Cross-Origin Resource Sharing)는 웹 애플리케이션의 보안 정책 중 하나로, 다른 출처(도메인, 프로토콜, 포트)로부터 리소스에 접근하는 것을 제한하는 웹 브라우저의 보안 메커니즘입니다. 

- 이 정책은 기본적으로 브라우저가 동일 출처 정책(Same-Origin Policy)를 준수하도록 하여 사용자의 개인 정보와 데이터를 보호합니다.

- CORS 정책을 만족하지 않는 경우에는 브라우저가 리소스 요청을 차단합니다. 일반적으로 다음과 같은 경우에 CORS 오류가 발생할 수 있습니다

```

1. 다른 도메인에서 AJAX 요청을 보내는 경우.

2. 다른 도메인에서 웹 폰트, 스타일시트, 스크립트 등의 리소스를 가져오는 경우.

3. 다른 도메인에서 API에 요청을 보내는 경우.

```

- CORS 오류를 해결하기 위해서는 서버 측과 클라이언트 측에서 다음과 같은 방법을 사용할 수 있습니다

```

- 서버 측 CORS 설정: 서버에서 Access-Control-Allow-Origin 헤더를 사용하여 특정 출처(도메인)에서의 요청을 허용하도록 설정할 수 있습니다. 

- 프록시 서버 사용: 서버 측에서 CORS 문제를 해결하기 어려운 경우, 프록시 서버를 사용하여 클라이언트와 서버 간의 통신을 중계할 수 있습니다. 프록시 서버는 클라이언트의 요청을 받아 서버로 전달하고, 서버의 응답을 받아 클라이언트에게 전달합니다. 이러한 방식으로 클라이언트와 서버 간의 동일 출처 정책을 준수할 수 있습니다.

- CORS 미들웨어 사용: 일부 백엔드 프레임워크에서는 CORS 문제를 해결하기 위한 미들웨어를 제공합니다. 이러한 미들웨어를 사용하여 간편하게 CORS 정책을 구성할 수 있습니다.

```

- CORS 오류를 해결하는 방법은 클라이언트와 서버 간의 통신 방식 및 환경에 따라 다를 수 있으며, 보안 상의 이유로 일부 제한적인 설정이 필요할 수 있습니다.

<br>

### 쿠키, 세션, 웹스토리지

- 쿠키(Cookie), 세션(Session), 그리고 웹 스토리지(Web Storage)는 모두 클라이언트 측에서 데이터를 저장하는 방식이지만, 각각의 동작 방식과 용도에는 차이가 있습니다.

1. 쿠키 (Cookie)

- 쿠키는 클라이언트 측에 저장되는 작은 데이터 조각입니다. 주로 서버와 클라이언트 간의 상태 정보를 유지하기 위해 사용됩니다. 예를 들어, 로그인 상태 유지, 사용자 환경 설정 등에 사용될 수 있습니다.

- 쿠키는 클라이언트의 브라우저에 저장되며, 만료 날짜가 지정되어 있으면 해당 날짜까지 유지됩니다. 만료 날짜가 지정되지 않으면 브라우저가 종료될 때까지 유지됩니다.

- 보안 문제로 인해 쿠키는 민감한 정보를 저장하는 데에는 적합하지 않으며, 주로 식별자나 세션 토큰 등의 작은 정보를 저장하는 데에 사용됩니다.

2. 세션 (Session)

- 세션은 클라이언트와 서버 간의 상태 정보를 유지하는 데 사용되는 메커니즘입니다. 클라이언트가 서버에 최초로 요청을 보내면 서버는 고유한 세션 ID를 생성하고, 이 세션 ID를 클라이언트에게 쿠키로 전송합니다.

- 클라이언트는 이 세션 ID를 쿠키에 저장하고, 이후의 모든 요청에 이 세션 ID를 함께 보냅니다. 서버는 세션 ID를 사용하여 클라이언트의 상태를 추적하고 관리합니다. 세션은 서버 측에 저장되기 때문에 브라우저를 종료하더라도 세션은 유지됩니다.

3. 웹 스토리지 (Web Storage)

- 웹 스토리지는 클라이언트 측에서 데이터를 저장하는 데 사용되는 메커니즘입니다. 웹 스토리지에는 로컬 스토리지(Local Storage)와 세션 스토리지(Session Storage) 두 가지 종류가 있습니다.

- 로컬 스토리지는 데이터를 영구적으로 저장하며, 사용자가 브라우저를 종료하거나 컴퓨터를 재부팅해도 데이터가 유지됩니다. 세션 스토리지는 데이터를 세션 동안에만 유지합니다. 세션이 종료되면 데이터가 삭제됩니다.

- 웹 스토리지는 보통 텍스트 형식의 데이터를 키-값 쌍으로 저장하며, 브라우저의 로컬 파일 시스템에 저장됩니다.

<br>

- 세션은 주로 로그인 상태와 같은 사용자 인증 정보를 유지하는 데 사용되며, 쿠키와 웹 스토리지는 클라이언트 측에서 상태 정보를 유지하는 데 사용됩니다.

<br>

### 로그인 시 쿠키 & 세션 인증 방식

- 로그인 처리를 할 때 쿠키와 세션을 사용하는 일반적인 방법은 다음과 같습니다.

1. 로그인 처리

- 사용자가 로그인을 시도하면, 서버는 사용자의 인증 정보를 확인합니다. 이것은 주로 사용자가 제공한 아이디와 비밀번호를 사용하여 이루어집니다.

- 서버는 사용자가 올바른 인증 정보를 제공했을 경우, 로그인 상태를 유지하기 위한 고유한 세션 ID를 생성합니다. 세션 ID는 일반적으로 서버 측에서 생성되며, 이를 쿠키로 클라이언트에게 전송하여 클라이언트 측에서 유지합니다.

2. 쿠키 설정

- 서버는 세션 ID를 쿠키로 설정하여 클라이언트에게 전송합니다. 이를 위해 Set-Cookie 헤더를 사용하여 클라이언트의 브라우저에 쿠키를 설정합니다.

- 보통 세션 쿠키는 브라우저가 종료될 때까지 유지되도록 설정됩니다. 따라서 사용자가 브라우저를 닫아도 세션 쿠키는 유지되며, 다시 브라우저를 열면 그대로 유지됩니다.

3. 세션 관리

- 클라이언트가 다시 요청을 보낼 때마다, 클라이언트가 보유한 세션 쿠키를 서버에 함께 전송합니다. 서버는 클라이언트의 세션 쿠키를 확인하여 세션 ID를 추출하고, 해당 세션 ID에 해당하는 사용자의 로그인 상태를 확인합니다.

4. 로그아웃 처리

- 사용자가 로그아웃을 요청하면, 서버는 해당 사용자의 세션 ID를 무효화하고 세션 데이터를 삭제합니다. 또한 클라이언트에게 전송된 세션 쿠키를 만료시킵니다. 이를 위해 Set-Cookie 헤더에 만료 날짜를 이전으로 설정하여 클라이언트의 브라우저가 해당 쿠키를 삭제하도록 합니다.

<br>

### 토큰 기반 인증 방식 

- 토큰 기반 인증은 클라이언트와 서버 간의 인증을 처리하는 방법 중 하나로, 보통 웹 및 모바일 애플리케이션에서 사용됩니다. 

- 토큰 기반 인증은 세션과 쿠키를 사용하는 전통적인 방식과 달리 상태를 서버에 저장하지 않고, 클라이언트 측에서 상태 정보를 저장하고 전송하는 방식을 채택합니다. 이를 통해 서버의 확장성과 유연성을 높일 수 있습니다.

1. 로그인 요청: 사용자가 인증을 요청할 때, 클라이언트는 사용자의 자격 증명(일반적으로 아이디와 비밀번호)을 서버로 보냅니다.

2. 인증 처리: 서버는 사용자의 자격 증명을 검증하고, 유효한 경우 사용자를 인증하고 토큰을 생성합니다. 이 토큰에는 사용자의 인증 정보와 권한 등이 포함될 수 있습니다.

3. 토큰 발급: 서버는 클라이언트에게 발급된 토큰을 전송합니다. 보통은 HTTP 응답의 일부로 헤더에 토큰을 포함하여 전송됩니다.

4. 토큰 저장: 클라이언트는 받은 토큰을 안전한 곳에 저장합니다. 주로 웹 애플리케이션에서는 브라우저의 로컬 스토리지나 세션 스토리지, 모바일 애플리케이션에서는 안전한 저장소에 저장됩니다.

5. 인증 요청: 클라이언트가 서버에 요청을 보낼 때마다, 토큰을 요청에 포함하여 전송합니다. 보통은 HTTP 요청의 Authorization 헤더에 토큰을 포함하여 전송됩니다.

6. 인증 확인: 서버는 클라이언트로부터 받은 토큰을 확인하고 유효한 경우 요청을 처리합니다. 토큰에는 클라이언트의 인증 정보와 권한 등이 포함되어 있으므로, 서버는 토큰을 검증하여 사용자의 인증 상태와 권한을 확인할 수 있습니다.

<br>

- 토큰 기반 인증은 상태를 서버에 저장하지 않고 클라이언트 측에서 관리하기 때문에 서버의 확장성을 높이고, 여러 플랫폼에서 사용하기 쉽습니다. 또한 토큰은 일반적으로 서명되어 있기 때문에 조작되지 않았음을 보장할 수 있습니다.

<br>

### JWT(JSON Web Token)

- 토큰 기반 인증 방식 중 JWT(JSON Web Token)가 널리 사용됩니다. JWT는 클라이언트와 서버 간의 인증을 처리하기 위한 표준화된 방법 중 하나이며, 특히 웹 및 모바일 애플리케이션에서 많이 사용됩니다.

- JWT는 JSON 포맷으로 인코딩된 토큰으로, 클라이언트와 서버 간의 안전한 통신을 위해 사용됩니다. 주로 다음과 같은 구성 요소로 이루어집니다

1. 헤더(Header): 토큰의 유형과 사용된 알고리즘 등의 정보를 포함합니다.

2. 페이로드(Payload): 클라이언트 및 서버 간 교환할 정보를 포함합니다. 사용자의 ID, 권한, 기타 사용자 정의 데이터 등이 여기에 포함될 수 있습니다.

3. 서명(Signature): 토큰의 유효성을 검증하기 위한 서명입니다. 서버가 비밀 키를 사용하여 토큰을 서명하고, 클라이언트가 서버로부터 전송받은 토큰의 유효성을 검증할 때 사용됩니다.

<br>

- JWT는 토큰을 안전하게 전달하고 저장하기 위해 암호화되어 있으며, 클라이언트 측에서 사용자 정보를 저장하고 전송하기 위해 일반적으로 쿠키나 웹 스토리지 등에 저장됩니다. 

- 클라이언트는 서버로부터 받은 JWT를 사용하여 인증 요청을 보내고, 서버는 JWT를 검증하여 사용자의 인증 상태를 확인합니다.


<br>

### 쿠키 & 세션 vs JWT

- 쿠키/세션 기반 인증 방식과 JWT(JSON Web Token) 기반 인증 방식은 각각 장단점을 가지고 있습니다.

1. 쿠키/세션 기반 인증 방식 장점

- 보안: 쿠키는 HttpOnly 속성을 사용하여 JavaScript를 통한 액세스를 방지하고, Secure 속성을 사용하여 안전한 통신을 보장할 수 있습니다.

- 유연성: 세션은 서버 측에 저장되기 때문에 서버의 확장성과 유연성을 높일 수 있습니다.

- 로그아웃 관리: 서버에서 세션을 중지시키거나 세션을 만료시켜 사용자의 로그아웃을 관리할 수 있습니다.

2. 쿠키/세션 기반 인증 방식 단점

- 상태 관리: 서버에서 세션 상태를 유지해야 하므로 서버 자원을 사용하고 관리해야 합니다.

- 크로스 도메인 제약: 쿠키는 도메인 간에 공유되지 않기 때문에 다른 도메인에서 사용하기 어려울 수 있습니다.

<br>

3. JWT 기반 인증 방식 장점

- 상태 저장 X: 토큰 기반 인증 방식이기 때문에 서버에 세션 상태를 저장할 필요가 없어 서버의 확장성을 높일 수 있습니다.

- 크로스 도메인 편의성: 토큰은 클라이언트 측에서 저장되므로 다른 도메인에서도 쉽게 전달 및 사용할 수 있습니다.

- 유연성: 토큰에는 사용자의 인증 정보와 권한 등이 포함되어 있으므로 더 많은 유연성을 제공합니다.

4. JWT 기반 인증 방식 단점

- 보안: 토큰은 클라이언트 측에 저장되므로 안전한 저장소에 보관되어야 하며, XSS 및 CSRF 공격에 취약할 수 있습니다.

- 크기: 토큰은 정보를 Base64 인코딩하여 전송되기 때문에 크기가 크고, 모든 요청에 토큰이 포함되어야 하므로 약간의 대역폭을 소비할 수 있습니다.

```
// JWT 토큰을 쿠키에 저장하였을 때 보안 취약점

1. XSS(Cross-Site Scripting) 공격: 쿠키에 저장된 JWT 토큰은 브라우저의 쿠키 저장소에 저장됩니다. 따라서 악의적인 사용자가 XSS 공격을 통해 악의적인 스크립트를 삽입하고 실행할 수 있습니다. 이 경우, 악의적인 스크립트가 쿠키에 저장된 JWT 토큰을 탈취하고 다른 도메인에 전송하여 인증을 우회할 수 있습니다.

2. CSRF(Cross-Site Request Forgery) 공격: 쿠키에 저장된 JWT 토큰은 모든 요청에 자동으로 포함되므로, CSRF 공격에 취약할 수 있습니다. 공격자는 피해자의 브라우저에 CSRF 스크립트를 삽입하여 악의적인 요청을 실행하도록 유도할 수 있습니다. 이 경우, 쿠키에 저장된 JWT 토큰이 함께 전송되어 인증된 요청으로 간주되어 피해자의 권한으로 서버에 접근할 수 있습니다.

3. 쿠키 보안 설정: 쿠키에 저장된 JWT 토큰의 보안은 쿠키의 속성에 의해 결정됩니다. Secure 및 HttpOnly 속성을 설정하여 SSL/TLS 연결을 통한 안전한 통신을 보장하고, JavaScript를 통한 액세스를 제한할 수 있습니다. 또한, SameSite 속성을 설정하여 동일 출처 정책을 강화할 수 있습니다.

```

<br>

### 크로스 브라우징(Cross Browsing)

- 크로스 브라우징(Cross Browsing)은 다양한 웹 브라우저 및 플랫폼에서 일관된 사용자 경험을 제공하는 웹 사이트 또는 웹 애플리케이션을 개발하는 과정입니다. 이는 웹 개발자가 여러 웹 브라우저 및 기기에서 웹 사이트가 동일한 방식으로 작동하고 보이도록 보장하는 것을 의미합니다.

- 크로스 브라우징을 실현하기 위해서는 다음과 같은 요소들을 고려해야 합니다.

1. HTML, CSS, JavaScript 호환성: 각 브라우저마다 HTML, CSS, JavaScript의 표준을 다르게 해석할 수 있기 때문에, 표준에 따른 개발 및 문법 준수가 필요합니다. 특히, 오래된 버전의 인터넷 익스플로러(IE)와 같은 브라우저에서는 특히 호환성 문제가 발생할 수 있습니다.

2. 브라우저 테스트: 다양한 웹 브라우저 및 기기에서 웹 사이트를 테스트하여 레이아웃, 기능 및 사용자 경험을 확인해야 합니다. 대표적인 브라우저로는 Google Chrome, Mozilla Firefox, Apple Safari, Microsoft Edge 등이 있습니다.

3. 폴리필(Polyfill) 사용: 폴리필은 특정 기능이나 API를 지원하지 않는 오래된 브라우저에서도 해당 기능을 사용할 수 있도록 도와주는 코드입니다. 특정 기능이 지원되지 않는 브라우저에서 필요한 경우 폴리필을 사용하여 기능을 구현할 수 있습니다.

4. 프로그레시브 향상 방식: 기본 기능은 모든 브라우저에서 지원되도록 설계하고, 그 이후에 추가적인 기능이나 향상된 경험을 지원하는 방식으로 개발합니다. 이를 통해 오래된 브라우저에서도 기본 기능은 사용할 수 있도록 보장합니다.

5. CSS 리셋(CSS Reset) 및 노멀라이즈(CSS Normalize): 각 브라우저의 기본 스타일 차이를 보정하기 위해 CSS 리셋 또는 노멀라이즈를 사용하여 일관된 스타일링을 적용할 수 있습니다.

<br>

### 웹 사이트 성능 최적화

- 웹 사이트의 성능 최적화를 위해 다양한 방법들이 있습니다.

1. 이미지 최적화: 이미지는 웹 페이지의 대부분의 데이터를 차지하므로, 이미지를 최적화하여 파일 크기를 줄이고 로딩 시간을 단축할 수 있습니다.이미지 포맷을 선택하고 압축을 사용하여 최적화하고, 필요한 경우 Lazy Loading을 구현하여 페이지의 초기 로딩 시간을 최소화할 수 있습니다.

2. 파일 압축과 미니파이: CSS, JavaScript 및 HTML 파일을 압축하고 미니파이하여 파일 크기를 줄이고 로딩 시간을 단축할 수 있습니다. 이를 통해 네트워크 대역폭을 절약하고 페이지 로딩 속도를 향상시킬 수 있습니다.

3. 브라우저 캐싱 활용: 브라우저 캐싱을 통해 리소스를 로컬에 저장하여 다시 다운로드하지 않고도 페이지 로딩 시간을 단축할 수 있습니다. 적절한 캐싱 정책을 설정하여 정적 파일의 캐싱 기간을 최대화하고, 캐시 무효화를 피하여 브라우저 캐싱을 효과적으로 활용할 수 있습니다.

4. 렌더링 최적화: CSS와 JavaScript를 최대한 간소화하고, 효율적으로 렌더링되도록 조치를 취하여 페이지의 렌더링 속도를 향상시킬 수 있습니다. 필요하지 않은 CSS 및 JavaScript를 제거하고, Critical CSS 및 Critical JavaScript를 사용하여 페이지의 첫 번째 로딩 속도를 최적화할 수 있습니다.

5. 서버 측 최적화: 서버 측에서도 성능 최적화를 수행하여 데이터베이스 쿼리의 효율성을 높이고, 서버 응답 시간을 최소화할 수 있습니다. CDN(Content Delivery Network)을 사용하여 정적 파일을 캐시하고 더 빠르게 제공할 수 있습니다.

6. 모바일 최적화: 모바일 기기에서의 웹 사이트 접근성을 고려하여 레이아웃, 이미지 크기 및 기타 리소스를 최적화하고, 모바일 터치 제스처와 관련된 사용자 경험을 향상시킬 수 있습니다.

- 이러한 방법들을 적절히 조합하여 웹 사이트의 성능을 최적화할 수 있으며, 사용자 경험을 향상시키고 검색 엔진 최적화(SEO)에도 도움을 줄 수 있습니다.

<br>

### 객체 지향 프로그래밍(Object-Oriented Programming, OOP)

- 객체 지향 프로그래밍(Object-Oriented Programming, OOP)은 프로그래밍 패러다임 중 하나로, 현실 세계의 개념을 프로그래밍에 반영하여 소프트웨어를 모듈화하고 재사용 가능한 코드를 작성하는 방법론입니다. OOP는 다음과 같은 주요 특징을 가지고 있습니다:

1. 클래스(Class)와 객체(Object): 클래스는 데이터와 데이터를 처리하는 메서드(함수)를 함께 묶어놓은 설계 도구입니다. 객체는 클래스의 인스턴스로, 클래스에서 정의한 속성과 메서드를 가집니다.

2. 캡슐화(Encapsulation): 클래스는 데이터와 해당 데이터를 조작하는 메서드를 하나의 단위로 캡슐화하여 외부로부터 데이터에 직접적인 접근을 제한하고, 데이터의 무결성을 보호합니다.

3. 상속(Inheritance): 상속은 기존 클래스에서 정의한 속성과 메서드를 다른 클래스가 재사용할 수 있도록 해주는 기능입니다. 이를 통해 코드의 재사용성과 확장성을 높일 수 있습니다.

4. 다형성(Polymorphism): 다형성은 같은 이름의 메서드를 서로 다른 방식으로 구현할 수 있도록 해주는 개념입니다. 다형성을 통해 한 메서드가 다양한 객체에서 다양하게 동작할 수 있습니다.

<br>

### JavaScript 객체 지향

- JavaScript는 객체 지향 언어입니다. JavaScript에서 객체는 속성과 메서드를 포함하는 컨테이너입니다. JavaScript의 객체는 클래스 기반의 객체 지향 언어인 Java나 C++과는 다르게 프로토타입 기반의 객체 지향 언어입니다. 

- 이는 JavaScript에서 클래스 없이도 객체를 만들 수 있으며, 기존 객체를 프로토타입으로 사용하여 새로운 객체를 만들 수 있다는 의미입니다.

- JavaScript에서는 객체를 생성하고 조작하는 데에 주로 JSON(JavaScript Object Notation) 형식을 사용하며, 프로토타입 체인(Prototype Chain)을 통해 객체 간의 상속을 구현합니다. 

- 또한, ES6(ECMAScript 2015)부터는 클래스와 상속을 공식적으로 지원하여 보다 명확하고 구조화된 객체 지향 프로그래밍을 할 수 있도록 하였습니다.

<br>

```
// 객체 지향 프로그래밍의 장단점

1. 장점

- 재사용성(Reusability): 클래스와 상속을 통해 코드의 재사용성을 높일 수 있습니다. 이미 작성된 클래스나 메서드를 재활용하여 새로운 기능을 구현할 수 있습니다.

- 유지보수성(Maintainability): 객체 지향 프로그래밍은 코드를 클래스와 메서드로 나누어 구조화하므로 코드의 유지보수가 용이합니다. 변경이 필요한 부분을 식별하고 수정하기 쉽습니다.

- 확장성(Scalability): 새로운 클래스를 추가하거나 상속을 통해 기존 클래스를 확장하여 새로운 기능을 추가할 수 있습니다. 이를 통해 애플리케이션의 확장성을 높일 수 있습니다.

- 유연성(Flexibility): 다형성을 통해 객체의 동작을 변경할 수 있으므로, 유연하고 확장 가능한 시스템을 구축할 수 있습니다.

2. 단점

- 복잡성(Complexity): 객체 지향 프로그래밍은 클래스와 객체의 개념을 이해하고, 상속 및 다형성과 같은 개념을 숙지해야 합니다. 이로 인해 초기 학습이 어려울 수 있습니다.

- 성능(Performance): 객체 지향 프로그래밍은 함수 호출 및 객체 생성과 관련된 오버헤드가 발생할 수 있으며, 이로 인해 성능 저하가 발생할 수 있습니다.

- 메모리 사용량(Memory Usage): 객체 지향 프로그래밍은 객체를 생성하고 메모리에 할당하는 과정이 필요하므로, 메모리 사용량이 증가할 수 있습니다. 특히 객체가 많이 생성되는 경우 메모리 관리에 주의해야 합니다.

- 설계 과정(Design Complexity): 객체 지향 프로그래밍은 설계 단계에서 클래스와 객체의 관계를 고려해야 하므로 설계 과정이 복잡해질 수 있습니다. 적절한 클래스 및 객체의 분리와 관계를 설정하는 것이 필요합니다.

```

<br>

### REST(Representational State Transfer) API

- REST(Representational State Transfer)는 웹 기반의 시스템을 위한 아키텍처적인 스타일 중 하나로, 리소스를 이름(URI)으로 식별하여 해당 리소스의 상태를 주고 받는 방식을 기술합니다. RESTful API는 이러한 REST 아키텍처 원칙을 따르는 API를 말합니다.

1. 자원(리소스) 중심: 모든 자원에 고유한 URI를 부여하여 해당 자원을 식별합니다. 예를 들어, /users, /products, /orders 등의 URI를 사용하여 각각의 사용자, 제품, 주문과 같은 자원을 나타냅니다.

2. HTTP 메서드 활용: HTTP 메서드(GET, POST, PUT, DELETE)를 사용하여 해당 자원에 대한 행위를 정의합니다. 예를 들어, GET 메서드는 자원의 조회, POST 메서드는 자원의 생성, PUT 메서드는 자원의 수정, DELETE 메서드는 자원의 삭제를 의미합니다.

3. 상태 정보의 전송: 클라이언트와 서버 간의 통신은 상태 정보를 전송하여 통신의 상태를 정의합니다. 상태 정보는 HTTP 헤더, HTTP 상태 코드, 응답 본문의 데이터 형식으로 전송됩니다.

4. 무상태(Stateless) 통신: RESTful API는 통신 간의 상태를 유지하지 않고, 각 요청은 독립적으로 처리됩니다. 이를 통해 서버의 확장성과 성능을 높일 수 있습니다.

5. 캐시(Cacheable) 지원: HTTP의 캐싱 기능을 활용하여 응답을 캐시할 수 있습니다. 캐시를 사용함으로써 응답 시간을 최소화하고 네트워크 대역폭을 절약할 수 있습니다.

<br>

- RESTful API는 웹 기반의 다양한 시스템 간에 표준화된 인터페이스를 제공하여 상호 운용성을 보장하고, 클라이언트와 서버 간의 분리를 통해 시스템의 확장성과 유연성을 높입니다. 

- RESTful API는 다양한 클라이언트(웹 애플리케이션, 모바일 앱 등)와 서버(웹 서비스, 마이크로서비스 등) 간의 통신을 위한 가장 일반적인 방법 중 하나입니다.

<br>

### SEO(Search Engine Optimization)

- SEO(Search Engine Optimization: 검색 엔진 최적화)는 검색 엔진에서 웹 사이트가 노출되도록 최적화하는 프로세스를 말합니다. 이는 웹 사이트의 트래픽을 증가시키고 유기적인 방문자를 유치하는 데 도움이 됩니다. 

- 주요 검색 엔진인 구글, 네이버, Bing 등은 수많은 웹 페이지 중에서 검색 결과를 보여주는데, 이때 SEO가 중요한 역할을 합니다.

- SEO를 위한 주요 전략

1. 키워드 연구(Keyword Research): 사용자들이 검색하는 키워드를 연구하고 해당 키워드를 웹 페이지의 콘텐츠에 통합합니다. 이를 통해 검색 엔진이 해당 웹 페이지를 적절한 검색 결과로 판단할 수 있습니다.

2. 콘텐츠 최적화(Content Optimization): 웹 페이지의 콘텐츠를 풍부하고 유용하게 작성하여 검색 엔진이 해당 웹 페이지의 내용을 이해하고 노출시킬 수 있도록 합니다. 키워드를 자연스럽게 삽입하고 고유하고 유용한 콘텐츠를 제공하는 것이 중요합니다.

3. 메타 태그 최적화(Meta Tags Optimization): 웹 페이지의 메타 태그(제목 태그, 설명 태그, 키워드 태그 등)를 최적화하여 검색 엔진이 해당 웹 페이지를 적절한 검색 결과로 인식하도록 합니다.

4. 링크 빌딩(Link Building): 다른 웹 사이트로부터 링크를 얻어 해당 웹 페이지의 권위성을 높이는 것입니다. 품질 높은 백링크를 획득하여 검색 엔진의 신뢰도를 높이고 검색 순위를 개선할 수 있습니다.

5. 모바일 최적화(Mobile Optimization): 모바일 기기에서의 웹 사이트 접근성을 고려하여 웹 사이트를 최적화합니다. 모바일 친화적인 디자인 및 빠른 로딩 속도를 제공하여 모바일 검색 결과의 순위를 개선할 수 있습니다.

6. 사이트 속도 최적화(Site Speed Optimization): 웹 사이트의 로딩 속도를 개선하여 사용자 경험을 향상시키고 검색 엔진에서의 순위를 개선합니다. 이미지 최적화, 브라우저 캐싱, CDN(Content Delivery Network) 등을 활용하여 사이트 속도를 향상시킵니다.

<br>

- SEO는 지속적인 작업이 필요하며, 검색 엔진의 알고리즘 변화에 따라 최적화 전략도 조정되어야 합니다. 올바른 SEO 전략을 통해 웹 사이트의 가시성을 향상시키고 온라인 비즈니스의 성공에 기여할 수 있습니다.

<br>

