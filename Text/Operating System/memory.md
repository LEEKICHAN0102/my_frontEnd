# 메모리

- CPU가 실행하는 것은 모두 메모리에 올라와 있는 것들 입니다. 메모리 계층과 메모리의 관리에 대해서 알아봅시다.

<br>

### 메모리 계층

<img src="../../Images/Operating System/memorylayer.webp" />

- 메모리 계층은 레지스터, 캐시, 메모리, 저장장치로 구성되어 있습니다.

```

- 레지스터: CPU 안의 작은 메모리, 휘발성, 속도가 가장 빠름, 기억 용량이 가장 적은 특징을 가짐.

- 캐시: L1, L2 캐시를 지칭. 휘발성, 속도 빠름, 기억용량이 적음 - (L3 캐시도 존재함.)

- 메모리(주 기억장치): RAM을 가리킵니다. 휘발성, 보통 속도, 기억 용량 보통.

- 저장장치(보조기억장치): HDD, SSD를 가리키며 비휘발성, 속도 낮음, 기억 용량이 많음.

```

<br>

- RAM은 하드로부터 일정량의 데이터를 복사해서 임시 저장하고 이를 필요 시 마다 CPU에 빠르게 전달하는 역할을 합니다.

- 계층 위로 올라갈 수록 가격이 비싸지는데, 용량은 작아지지만 속도가 빨라지는 특징이 있습니다.

- 흔히 보이는 로딩중... 이라는 것은 하드디스크 또는 인터넷에서 데이터를 읽어 RAM으로 전송하는 과정이 아직 끝나지 않음을 의미하기도 합니다.

<br>

- 캐시(Cache)는 데이터를 미리 복사해 놓는 임시 저장소를 말합니다.

- 빠른 장치와 느린 장치간 속도 차이에 따른 병목 현상을 줄이기 위한 메모리를 말합니다.

- 데이터를 접근하는 시간이 오래 걸리는 경우를 해결하고, 다시 계산하는 시간을 줄일 수 있습니다.

<br>

### 웹 브라우저의 캐시

- 소프트웨어적인 대표 캐시로는 웹 브라우저의 작은 저장소인 쿠키, 로컬 스토리지, 세션 스토리지가 있습니다.

- 사용자의 커스텀 정보, 인증 모듈 관련 사항을 웹 브라우저에 저장하여 추후 서버에서 요청할 때 자신을 나타냅니다.

<br>

```

- 쿠키: 쿠키는 만료 기한이 있는 키-값 저장소입니다. same site 옵션을 strict로 설정하지 않았을 경우 다른 도메인에서 요청하였을 때 자동 전송되며, 4KB까지 데이터를 저장할 수 있고 만료기한을 설정할 수 있습니다. 쿠키를 설정할 때는 쿠키를 볼 수 없게 httponly 옵션을 설정하는 것이 중요합니다.

- 로컬 스토리지: 만료기한이 없는 키-값 저장소입니다. 10KB까지 저장 가능하며 웹브라우저를 닫아도 유지되고 도메인 단위로 저장, 생성됩니다. HTML5를 지원하지 않는 브라우저에서는 사용 불가능하며 클라이언트에서만 수정이 가능합니다.

- 세션 스토리지: 동일하게 만료기간 없는 키-값 저장소 입니다. 탭 단위로 세션 스토리지를 생성하며 탭을 닫을 때 해당 데이터가 삭제 됩니다. 5MB 까지 저장이 가능하며 HTML5 를 지원하지 않는 브라우저에서 사용 불가능 합니다. 클라이언트에서만 수정 가능합니다.

```

<br>

### 메모리 관리

- 운영체제의 대표적인 일 중 하나입니다. 컴퓨터 내의 한정된 메모리를 활용하는 방법입니다.

<br>

#### 가상 메모리

- 가상 메모리(Virtual Memory)는 메모리 관리 기법의 하나로써 컴퓨터가 실제로 이용 가능한 메모리 자원을 추상화하여 이를 사용하는 사용자들에게 매우 큰 메모리로 보이게하는 것을 말합니다.

- 이 떄 가상적으로 주어진 주소를 지역 주소(logical address), 가상주소라고 하며 실제 메모리에 있는 주소를 실제 주소(physical address)라고 합니다. 가상 주소는 메모리관리장치(MMU)에 의해 실제 주소로 변환되며 이로 인해 사용자는 실제 주소를 의식할 필요 없이 프로그램 구축이 가능합니다.

- 가상 메모리는 가상 주소와 실제 주소가 매핑되어 있고 프로세스의 주소 정보가 들어 있는 페이지 테이블로 관리 되며 속도 향상을 위해 TLB를 씁니다.

- TLB: 메모리와 CPU 사이에 있는 주소 변환을 위한 캐시. 페이지 테이블의 리스트를 보관하며 CPU가 페이지 테이블까지 가지 않도록 하여 속도를 향상.

<br>

#### 스와핑

- 만약 가상 메모리에는 존재 하지만 실제 메모리인 RAM에는 현재 없는 데이터나 코드에 접근할 경우 페이지 폴트가 발생 합니다.

- 이때 메모리에서 당장 사용하지 않는 영역을 HDD로 옮기고 HDD의 일부분을 메모리 처럼 불러와 사용하는 것을 스와핑이라고 합니다.

- 이렇게 하여 페이지 폴트가 일어나도 일어나지 않은 것처럼 만들 수 있습니다.

<br>

#### 페이지 폴트(Page Fault)

- 페이지 폴트란 프로세스의 주소 공간에는 존재하지만 현재 컴퓨터 RAM에는 없는 데이터에 접근했을 경우 발생합니다.

- 다음과 같은 과정으로 페이지 폴트와 스와핑이 이루어집니다.

```

1. CPU는 물리 메모리를 확인 => 해당 페이지가 없으면 트랩을 발생하여 운영체제에 알림.

2. 운영체제는 CPU 동작을 잠시 멈춤.

3. 운영체제는 페이지 테이블을 확인 => 가상 메모리에 페이지가 존재 하는지 확인 => 없으면 프로세스 중단후 물미 메모리에 빈 프레임을 찾음.

4. 물리 메모리에도 없다면 스와핑 발생.

5. 비어 있는 프레임에 해당 페이지 로드 & 페이지 테이블 최신화.

6. 중단 된 CPU 다시 실행.

- 페이지: 가상 메모리를 사용하는 최소 크기 단위.

- 프레임: 실제 메모리를 사용하는 최소 크기 단위.

```

<br>

### 스레싱(Thrashing)

- 스레싱은 메모리의 페이지 폴트율이 높은 것을 의미합니다.

- 메모리에 너무 많은 프로세스가 동시에 올라올 때 스와핑이 많이 일어나면서 발생 합니다.

- 해결 방법은 메모리를 늘리거나, HDD를 사용한다면 HDD를 SSD로 바꾸거나, 작업 세트 & PFF가 있습니다.

<br>

#### 작업세트

- 작업 세트(working set)는 프로세스의 과거 사용 이력인 지역성(locality)을 통해 결정된 페이지 집합을 만들어 미리 메모리에 로드하는 것 입니다.

- 이떄의 이점은 탐색에 드는 비용을 줄이고 스와핑 또한 줄일 수 있습니다.

<br>

#### PFF

- PFF(Page Fault Frequency)는 페이지 폴트 빈도를 조절하는 방법으로 상한, 하한선을 만드는 방법 입니다.

- 상한선에 도달한다면 프레임을 늘리고 하한선에 도달하면 프레임을 줄이는 방식 입니다.

<br>

### 메모리 할당 방식

- 메모리에 프로그램을 할당 할 때는 시작 메모리 위치, 메모리의 할당 크기를 기반으로 할당 하는데, 연속할당 불연속 할당으로 나뉩니다.

#### 연속할당

- 연속할당은 메모리에 연속적으로 공간을 할당하는 것을 말합니다.

- 공간에 순차적으로 메모리를 할당하는데 메모리를 미리 나누어 관리하는 고정 분할 방식, 매 시점 프로그램을 크기에 맞게 분할하는 가변 분할 방식으로 나뉩니다.

```

- 고정 분할 방식: Fixed Partition Allocation은 메모리를 미리 나누어 관리하는 방식이며, 메모리가 미리 나뉘어져 있기 때문에 효율적이지는 않습니다. 내부 단편화가 발생합니다.

- 가변 분할 방식: Variable Partition Allocation은 매 시점 프로그램의 크기에 맞게 동적으로 메모리를 나눠 사용합니다. 내부 단편화는 발생하지 않지만 외부 단편화가 발생할 수 있습니다. 이는 최초 적합, 최적 적합, 최악 적합이 있습니다.

```

<br>

```

- 최초 적합(First fit): 위쪽, 아래쪽부터 시작해서 홀을 찾으면 바로 할당합니다.

- 최적 적합(Best fit): 프로세스의 크기 이상인 공간 중 가장 작은 홀부터 할당합니다.

- 최악 적합(Worst fit): 프로세스의 크기와 가장 많이 차이가 나는 홀에 할당합니다.

```

<br>

```

- 내부 단편화(Internal Fragmentation): 메모리를 나눈 크기보다 프로그램이 작아서 들어가지 못하는 공간이 많이 발생하는 현상.

- 외부 단편화(External Fragmentation): 메모리를 나눈 크기보다 프로그램이 커서 들어가지 못하는 공간이 발생하는 현상.

- 홀(Hole): 할당할 수 있는 비어있는 메모리 공간을 말합니다.

```

<br>

#### 불연속할당

- 메모리를 연속적으로 할당하지 않는 방법으로 현대 운영체제가 많이 사용하는 방벙으로 페이징 기법이 있습니다.

- 메모리를 동일한 크기의 페이지(보통 4KB)로 나누고 프로그램마다 페이지 테이블을 두어 할당합니다. 세그멘테이션, 페이지드 세그멘테이션 등도 있습니다.


<br>

```

- 페이징(Paging): 페이징은 동일한 크기의 페이지 단위로 나누어 메모리의 서로 다른 위치에 프로세스를 할당합니다. 홀의 크기가 균일하지 않은 문제가 없어지지만, 주소 변환이 복잡해집니다.

- 세그멘테이션(Segmentation): 페이지 단위가 아닌 의미 단위인 세그먼트로 나누는 방식 입니다. 프로세스 메모리는  코드영역, 데이터 영역, 스택 영역, 힙 영역으로 이루어지는데 코드와 데이터로 나누거나 코드 내의 작은 함수를 세그먼트로 놓고 나눌 수 있습니다. 공유, 보안 측면에서 장점이 있지만 홀 크기가 균일하지 않은 단점이 있습니다.

- 페이지드 세그멘테이션(Paged Segmentation): 세그멘테이션과 동일하지만, 임의의 길이가 아닌 페이지 단위로 나누는 것을 말합니다.

```

<br>

### 페이지 교체 알고리즘

- 메모리가 한정되어 있기 때문에 스와핑이 많이 일어납니다. 스와핑은 많이 일어나지 않도록 설계 되어야 하며, 이 페이지 교체 알고리즘을 기반으로 스와핑이 일어납니다.

<br>

#### 오프라인 알고리즘

- 미래에 참조되는 페이지와 현재 할당하는 페이지를 바꾸는 알고리즘 이며 가장 좋은 방법 입니다.

- 미래에 사용되는 프로세스를 알 수 없기 때문에 사용할 수 없는 알고리즘 입니다.

- 하지만 가장 좋은 알고리즘 이기 때문에, 다른 알고리즘과의 성능 비교에 대한 상한기준(Upper_Bound)를 제공합니다.

<br>

- FIFO: First In Last Out은 가장 먼저 온 페이지를 교체 영역에 가장 먼저 놓는 방법을 의미합니다.

- LRU: Least Recently Used는 참초가 가장 오래 된 페이지를 바꿉니다. 오래된 것을 파악하기 위해 페이지 마다 계수기, 스택을 두어야하는 문제가 있습니다. 두개의 자료구조로 구현할 수 있는데 해시 테이블과 이중 연결 리스트입니다.

- NUR: LRU에서 발전한 Not Used Recently는 일명 clock 알고리즘 이라고 하며 0과 1을 가진 비트를 둡니다. 1은 최근에 참조 된, 0은 그렇지 않음을 의미 합니다. 시계 방향으로 돌며 0을 찾곡 0을 찾은 순간 해당 프로세스를 교체하고, 해당 부분을 1로 바꾸는 알고리즘 입니다.

- LFU: Least Frequently Used는 가장 참조 횟수가 적은 페이지를 교체합니다. 많이 사용 되지 않은 것으로 교체하는 방식입니다.

<br>




