# 프로세스와 스레드

- 프로세스는 컴퓨터에서 실행되고 있는 프로그램을 말하며 CPU 스케쥴링의 대상이 되는 작업(task)이라는 용어와 거의 같은 의미로 사용됩니다.

- 스레드는 프로세스 내 작업의 흐름을 말합니다.

- 프로그램이 메모리에 올라가면 프로세스로 변환 되는 인스턴스화가 일어나고 운영체제의 CPU 스케쥴러에 따라 CPU가 프로세스를 실행합니다.

<br>

### 프로세스와 컴파일 과정

- 프로세스는 프로그램이 메모리에 올라가 인스턴스화 된 것을 말합니다.

- 구글 크롬 프로그램(Chrome.exe)와 같은 실행 파일이 프로그램이며 이를 클릭하였을 때 크롬 프로세스로 변환 되는 것 입니다.

<img src="../../Images/Operating System/compilelayer.png" />

- 컴파일이 실행되는 과정은 다음과 같습니다.

<br>

```

- 전처리: 소스 코드의 주석을 제거하고 #include 등 헤더 파일을 병합하여 매크로를 치환 합니다(C, C++).

- 컴파일러: 오류 처리, 코드 최적화 작업 => 어셈블리어로 변환 됩니다.

- 어셈블러: 어셈블리어는 목적 코드(Object Code)로 변환 됩니다. 이떄 확장자는 운영체제마다 다른데 리눅스의 경우 .o 확장자로 변환 시킵니다.

- 링커: 프로그램 내에 있는 라이브러리 함수 또는 다른 파일들과 목적 코드를 결합하여 실행 파일을 만듭니다. 실행 파일 확장자의 경우 .exe 또는 .out 확장자를 갖습니다.

```

<br>

#### 정적, 동적 라이브러리

- 라이브러리는 정적과 동적으로 나뉩니다. 

- 정적 => 프로그램 빌드 시 라이브러리 제공하는 모든 코드를 실행 파일에 넣는 방식. 시스템 환경 등의 외부 의존도가 낮은 장점, 코드 중복등의 메모리 효율성이 떨어지는 단점.

- 동적 => 프로그램 실행 시 필요할 때만 DLL이라는 함수 정보를 통해 참조하여 라이브러리를 사용하는 방법. 메모리 효율성이 좋은 장점, 외부 의존도가 높아지는 단점.

<br>

### 프로세스의 상태

- 프로세스는 여러가지 상태 값을 가집니다.

- 생성, 대기, 대기 중단, 실행, 중단, 일시 중단, 종료로 나뉩니다.

<br>

```

- 생성 상태: 프로세스가 생성된 상태,  fork(), exec() 함수를 통해 생성 => PCB할당.

- 대기 상태: 메모리 공간이 충분하면 메모리를 할당 받고 아니면 아닌 상태로 대기 하고 있으며 CPU 스케줄러로부터 CPU 소유권이 넘어오기를 기다리는 상태.

- 대기 중단 상태: 메모리 부족으로 일시 중단 된 상태.

- 실행 상태: CPU 소유권과 메모리를 할당받고 인스트럭션을 수행 중인 상태를 의미. => CPU burst가 일어났다고도 함.

- 중단 상태: 어떤 이벤트가 발생한 이후 기다리며 프로세스가 차단된 상태. I/O 디바이스에 의한 인터럽트로 발생하기도 함.

- 일시 중단 상태: 대기 중단과 유사. 중단된 상태에서 프로세스가 실행되려고 했지만, 메모리 부족으로 일시 중단 된 것을 말함.

- 종료 상태: 메모리와 CPU 소유권을 모두 놓고 가는 상태. 자연스럽게 종료되는 경우도 있지만, 부모 프로세스가 자식 프로세스를 강제시키는 비자발적 종료, 사용자가 process.kill 등의 명령어를 사용하여 종료 시킬때 발생.

```

<br>

### 프로세스의 메모리 구조

- 운영체제는 프로세스에 적절한 메모리를 할당하는데 다음과 같은 구조를 기반으로 할당합니다.

<img src="../../Images/Operating System/processmemorystructure.png" />

<br>

#### 스택과 힙

- 스택과 힙은 동적 할당이 되며, 동적 할당은 런타임 단계에서 메모리를 할당 받는 것을 말합니다.

- 스택은 지역 변수, 매개변수, 실행되는 함수에 의해 늘어나거나 줄어드는 메모리 영역입니다.

- 함수가 호출될 때 마다 호출 될 때의 환경 등의 특정 정보가 스택에 계속해서 저장 됩니다.

- 재귀함수가 호출된다고 할때, 새로운 스택 프레임이 매번 사용되기 때문에 함수 내의 변수 집합이 해당 함수의 다른 인스턴스 변수를 방해하지 않습니다.

- 힙은 동적으로 할당되는 변수들을 담습니다. 동적으로 관리되는 자료 구조의 경우 힙 영역을 사용합니다.

<br>

#### 데이터 영역 & 코드 영역

- 정적 할당 되는 영역입니다. 정적 할당은 컴파일 단계에서 메모리를 할당하는 것을 말합니다.

- 데이터 영역은 BSS segment 와 Data segment, code/text segment로 나뉘어서 저장됩니다.

- BSS segment는 전역 변수 또는 static, const 로 선언되어 있고 0으로 초기화 또는 초기화가 어떠한 값으로도 되어있지 않은 변수들이 이 메모리 영역에 할당 됩니다. Data segment도 동일하지만 0이 아닌 값으로 초기화 된 변수가 이 영역에 할당 됩니다.

<br>

### PCB

- PCB(Process Control Block)이란 운영체제에서 프로세스에 대한 메타데이터를 저장한 데이터를 말합니다.

- 프로세스 제어블록이라고도 하고 프로세스가 생성되면 운영체제가 해당 PCB를 생성합니다.

- 프로세스의 중요한 정보를 포함하고 있기때문에 일반 사용자가 접근하지 못하도록 커널 스택의 가장 앞부분에서 관리 됩니다.

- 메타데이터: 데이터에 관한 구조화 된 데이터이자 데이터를 설명하는 작은 데이터.

<br>

### 컨텍스트 스위칭

- PCB를 교환하는 과정을 컨텐스트 스위칭이라고 합니다.

- 한 프로세스에 할당된 시간이 끝나거나, 인터럽트에 의해 발생합니다.

- 컴퓨터가 동시에 여러가지 프로그램을 수행하는 것 처럼 보이지만 사실 하나의 작업을 하고 있습니다. 여러가지가 동시에 이루어지는 것 처럼 보이는 것은 이 컨텍스트 스위칭이 빠르게 실행되고 있기 때문입니다.

<img src="../../Images/Operating System/contextswitching.png" />


- EX => 현대 컴퓨터에선는 멀티코어 CPU를 가지고 있기 떄문에 한 시점에 한개의 프로그램은 틀린 말이지만 이전에 사용되던 싱글 코어 기준 컨텍스트 스위칭의 역할이 매우 컷음.

- 위 그림 처럼 PCB1을 실행 하다 멈추고 저장 => PCB2 로드 후 실행 => PCB2 저장 후 PCB1 재실행하는 과정을 확인할 수 있습니다.

- 컨텍스트 스위칭이 일어날때 유휴 시간(Idle time)이 발생하는 것을 확인 할 수 있습니다. 또 다른 드는 비용에는 캐시미스도 있습니다.

- 캐시미스: 컨텍스트 스위칭이 일어날 때 프로세스가 가지고 있는 메모리 주소가 그대로 있으면 잘못된 주소 변환이 생기므로 캐시클리어 과정을 겪으면서 캐시미스가 발생합니다.

- 스레드에서의 컨텍스트 스위칭: 스레드에서도 일어나는 컨텍스트 스위칭은 스택 영역을 제외한 모든 메모리를 공유하기 때문에 스레드 컨텍스트 스위칭의 경우 비용이 더적고 시간도 더 적게 걸립니다.

<br>

### 멀티프로세싱

- 멀티프로세싱은 여러개의 프로세스, 즉 멀티프로세스를 통해 동시에 두 가지 이상의 일을 수행할 수 있는 것을 말합니다.

- 하나 이상의 일을 병렬 처리 할 수 있으며 특정 프로세스의 메모리, 프로세스 중 일부에 문제가 발생하더라도 다른 프로세스를 사용하여 처리하기에 신뢰성이 높습니다.

<br>

### 웹 브라우저

- 웹 브라우저는 멀티프로세스 구조를 가지고 있습니다.

<img src="../../Images/Operating System/webbrowserprocess.png" />

```

브라우저 프로세스: 주소 표시줄, 북마크 막대, 뒤로 가기 버튼등을 담당 => 네트워크 요청이나 파일 접근 같은 권한 담당.

렌더러 프로세스: 웹 사이트가 보이는 부분의 모든 것을 제어합니다.

플러그인 프로세스: 웹 사이트에서 사용하는 플러그인을 제어합니다.

GPU 프로세스: GPU를 이용해서 화면을 그리는 부분을 제어합니다.

```

<br>

### 스레드와 멀티스레딩

- 스레드: 스레드는 프로세스의 실행 가능한 가장 작은 단위를 뜻합니다. 프로세스는 여러개의 스레드를 가질 수 있습니다.

- 코드, 데이터, 스택, 힙을 각각 생성하는 프로세스와는 다르게 스레드는 코드, 데이터, 힙은 스레드끼리 서로 공유하고 그 외의 영역은 각각 생성됩니다.

- 멀티스레딩: 프로세스 내 작업을 여러 개의 스레드, 멀티스레드로 처리하는 기법이며 스레드끼리 서로 자원을 공유하기 때문에 효율적 입니다.

- 웹 서버의 경우 요청을 처리할 때 새 프로세스 대신 스레드를 생성하여 훨씬 적은 리소스를 소비합니다.

- 한 스레드가 중단(blocked)되어도 다른 스레드는 실행 상태일 수 있기 때문에 중단되지 않은 빠른처리가 가능합니다.

- 한 스레드에 문제가 생기면 다른 스레드에도 영향을 끼쳐 스레드로 이루어진 프로세스에 영향을 줄 수 있는 단점이 있습니다.


<br>

### 공유자원과 임계 영역

- 공유 자원(Shared Resource)은 시스템 안에서 각 프로세스, 스레드가 함께 접근할 수 있는 모니터, 프린트, 메모리, 파일 등의 자원이나 변수를 말합니다.

- 두 개 이상의 프로세스가 동시에 읽거나 쓰는 상황을 경쟁 상태라고 하며, 동시에 접근을 시도할 때 접근의 타이밍이나 순서 등이 결과 값에 영향을 줄 수 있습니다.

- 임계 영역(Critical Section)은 둘 이상의 프로세스, 스레드가 공유 자원에 접근할 때 순서 등의 이유로 결과가 달라지는 코드 영역을 말합니다.

- 해결 방법으로는 크게 뮤텍스, 세마포어, 모니터 세 가지 방법이 있으며, 상호 배제, 한정 대기, 융통성의 조건을 모두 만족 합니다. 

```

- 상호 배제: 한 프로세스가 임계 영역에 들어갔을 때 다른 프로세스는 들어갈 수 없다.

- 한정 대기: 특정 프로세스가 영원히 임계 영역에 들어가지 못하면 안 된다.

- 융통성: 한 프로세스가 다른 프로세스의 일을 방해해서는 안 된다.

세 가지 방법의 토대가 되는 매커니즘 => lock()

```

<br>

#### 임계 영역의 해결 방법

- 뮤텍스(Mutex): 프로세스나 스레드가 공유 자원을 lock()을 통해 잠금 설정하고 사용한 후에는 unlock()을 통해 잠금을 해제하는 객체.

- 세마포어(Semaphore): 일반화 된 뮤텍스, 간단한 정수 값과 두 가지 함수 wait(P 함수: 자신의 차례가 올때 까지 기다림) 및 signal(V 함수: 다음 프로세스로 순서를 넘김)로 공유 자원에 대한 접근처리.

- 모니터: 둘 이상의 스레드나 프로세스가 공유 자원에 안전하게 접근할 수 있도록 공유 자원을 숨기고 해당 접근에 대해 인터페이스만을 제공합니다.


<br>

### 교착 상태

- 교착 상태(Deadlock)은 두 개 이상의 프로세스들이 서로가 가진 자원을 기다리며 중단된 상태를 말합니다.

- 프로세스 A가 프로세스 B의 자원을 요청할 때 B 또한 A가 점유한 자원을 요청하는 것 => 서로 중단 되어버림.

- 상호 배제, 점유 대기, 비선점, 환형 대기등의 원인으로 교착상태가 일어나며 해결 방법은 자원을 할당할 때 초기에 조건이 성립 되지 않도록 설계하거나, 은행원 알고리즘, 교착 상태 발생 시 사이클을 찾아보고 관련 프로세스를 지우는 방식으로 해결 가능합니다.

- 교착 상태는 매우 드물게 일어나기 때문에 처리 비용이 더 커서 발생시에 사용자가 작업을 종료합니다. 현대 운영체제는 이와 같은 방식을 선택하였습니다. ("응답 없음"과 같은 경우를 말함)

```

- 점유 대기: 특정 프로세스가 점유한 자우너을 다른 프로세스가 요청하는 상태.

- 비선점: 다른 프로세스의 자원을 강제적으로 가져올 수 없음.

- 환형 대기: 프로세스 A가 B의 자원을 요구 B는 A 자원을 요구 하는 등의 서로가 서로의 자원을 요구하는 상황.

- 은행원 알고리즘: 총 자원의 양과 현재 할당한 자원의 양을 기준으로 안정 혹은 불안정한 상태로 나누고 안정상태로 가도록 자원을 할당하는 알고리즘

```

<br>

### CPU 스케쥴링 & 알고리즘

- CPU 스케쥴러는 스케쥴링 알고리즘에 따라 프로세스에서 해야 하는 일을 스레드 단위로 CPU에 할당합니다.

<img src="../../Images/Operating System/cpuschedulealgorithm.jpg" />

- 프로그램이 실행 될 때 CPU 스케쥴링 알고리즘이 어떤 프로그램에 CPU 소유권을 줄 지 결정 합니다.

- CPU 이용률은 높고 주어진 시간에 많은일을 할 수 있도록 준비 큐(Ready Queue)에 있는 프로세스는 적게, 응답 시간은 짧게 설정하는 것을 목표합니다.

<br>

### 비선점형 방식

- 비선점형 방식(non-preemptive)은 프로세스가 스스로 CPU 소유권을 포기하는 방식이며, 강제로 프로세스를 중지하지 않습니다.

- 컨텍스트 스위칭으로 인한 부하가 적습니다.

<br>

#### FCFS

- FCFS(First Come, First Served)는 가장 먼저 온 것을 가장 먼저 처리하는 알고리즘 입니다.

- 길게 수행 되는 프로세스 때문에 준비 큐에서 오래 기다리는 현상인 Convoy Effect 가 발생하는 단점이 있습니다.

<br>

#### SJF

- SJF(Shortest Job First)는 실행 시간이 가장 짧은 프로세스를 가장 먼저 실행하는 알고리즘 입니다.

- 긴 시간을 가진 프로세스가 실행 되지 않는 현상(Starvation)이 일어나며 평균 대기 시간이 가장 짧습니다.

- 실제로는 실행 시간을 알 수 없기 때문에 과거의 실행했던 시간을 토대로 추측해서 사용 합니다.

<br>

#### 우선순위

- 기존에 긴 시간을 가진 프로세스 실행되지 않는 현상(Starvation)이 있었는데, 오래된 작업일수록 우선 순위를 높이는 방법(Aging)을 통해 단점을 보완한 알고리즘 입니다.

<br>

### 선점형 방식

- 선점형 방식(Preemptive)은 현대 운영체제가 쓰는 방식으로 지금 사용하고 있는 프로세스를 알고리즘에 의해 중단시켜 버리고 강제로 다른 프로세스에 CPU 소유권 할당하는 방식을 말합니다.

<br>

#### 라운드 로빈

- 라운드 로빈(RR, Round Robin)은 현대 컴퓨터가 쓰는 스케쥴링인 우선순위 스케쥴링(Priority Scheduling)의 일종입니다.

- 각 프로세스는 동일한 할당 시간을 주고 그 시간안에 끝내지 않으면 다시 준비 큐의 뒤로 가는 알고리즘 입니다.

- Q 만큼의 할당 시간이 부여 되었을 때 N개의 프로세스가 운영 된다고 한다면 (N - 1) * Q 시간이 지났을 때 자신의 차례가 찾아 옵니다.

- 할당 시간이 너무 크면 FCFS가 되고 짧으면 컨텍스트 스위칭이 잦아져서 오버헤드(비용이 커짐)가 됩니다.

- 전체 작업 시간은 길어지지만 평균 응답 시간은 짧아지는 장점이 있습니다. => 로드밸런서에서 트래픽 분산 알고리즘으로도 사용.

<br>

#### SRF

- SRF(Shortest Remaining Time First)는 중간에 더 짧은 작업이 들어왔을 때 수행 하던 프로세스를 중지하고 해당 프로세스를 수행 하는 알고리즘 입니다.

- 더 짧은게 들어와도 기존의 작업을 수행하는 SJF와는 약간 다릅니다.

<br>

#### 다단계 큐

- 다단계 큐는 우선순위에 따른 준비 큐를 여러개 사용하고 큐 마다 라운드 로빈이나 FCFS등의 다른 스케쥴링 알고리즘을 적용한 것을 말합니다.

- 큐 간 프로세스 이동이 안 되므로 스케쥴링 부담이 적지만 유연성이 떨어지는 단점이 있습니다.