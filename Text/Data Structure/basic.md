# 자료 구조(Data Structure)

### 자료 구조란?

- 자료 구조는 효율적으로 데이터를 관리하고 수정, 삭제, 탐색, 저장 할 수 있는 데이터의 집합을 말합니다.

<br>

### 복잡도

- 복잡도는 시간 복잡도와 공간 복잡도로 나뉩니다.

<br>

#### 시간 복잡도

- 시간 복잡도란 "문제를 해결하는 데 걸리는 시간과 입력의 함수 관계"를 말합니다. 어떤 알고리즘의 로직이 얼마나 오랜 시간이 걸리는 지를 나타낼 때 사용 되며, 이를 보통 빅오 표기법으로 나타냅니다. 

- 시간 복잡도가 필요한 이유는 바로 효율적인 코드를 개선하는 데 쓰이는 척도가 되기 때문 입니다. 

<img src="../../Images/Data Structure/timecomplexity.png" />

- 위 그림을 보면 O(1)과 O(n)은 입력 크기가 커질 수록 차이가 많이 나는 것을 확인 할 수 있습니다. O(n^2), 보다 O(n), O(n) 보다 O(1)을 지향해야 합니다.

<br>

#### 공간 복잡도

- 공간 복잡도는 프로그램을 실행 시켰을 때 필요로 하는 자원 공간의 양을 말합니다.

> int a[1004]; // C++

- 위 C++ 예시에서는 a 배열은 1004 X 4 바이트의 크기를 가지게 되는데, 이러한 공간을 말합니다.

<br>

### 자료 구조에서의 시간 복잡도

- 자료 구조를 사용할 때 시간 복잡도를 잘 생각하여야 합니다.

<img src="../../Images/Data Structure/datastructurecomplexity.png">

- 위 이미지는 자주 사용 되는 자료 구조의 시간 복잡도를 나타낸 모습입니다. 시간 복잡도를 생각할 때 평균(Average), 최악(Worst)의 시간 복잡도를 고려하면서 사용 합니다.

<br>

### 선형 자료 구조

- 선형 자료 구조란 요소가 일렬로 나열 되어져 있는 자료 구조를 말합니다.

<br>

#### 연결 리스트(Linked List)

- 연결 리스트는 데이터를 감싼 노드를 포인터로 연결해서 공간 효윬성을 극대화 시킨 자료 구조 입니다. 삽입, 삭제가 O(1)이 걸리며 탐색에는 O(n)이 걸립니다.

<img src="../../Images/Data Structure/linkedlist.png"/>

```

- 싱글 연결 리스트: next 포인터 만을 가집니다.

- 이중 연결 리스트: next 포인터와 prev 포인터를 가집니다.

- 원형 이중 연결 리스트: 이중 연결 리스트와 같지만 마지막 노드의 next 포인터가 헤드(제일 첫 번째 노드) 노드를 가리킵니다.

```

<br>

### 배열(Array)

- 배열은 같은 타입의 변수들로 이루어져 있고, 크기가 정해져 있으며 인접한 메모리 위치에 있는 데이터들을 모아놓은 집합 입니다.

- 중복을 허용하고 순서가 존재 합니다.

- 탐색에 O(1)이 되어 랜덤 접근이 가능합니다. 삽입, 삭제에는 O(n)이 걸립니다. 

- 따라서 데이터 추가와 삭제를 할 때는 연결 리스트, 탐색을 할 때에는 배열로 하는 것이 좋습니다.

<br>

#### 랜덤 접근, 순차적 접근

- 직접 접근 이라고도 하는 랜덤 접근은 배열과 같은 순차적인 데이터가 있을 떄, 동일한 시간에 임의의 인덱스에 해당하는 데이터에 접근 가능한 기능을 말합니다.

- 데이터를 저장 된 순서대로만 검색해야 하는 순차적 접근과는 반대의 개념에 있습니다.

<br>

#### 배열과 연결 리스트 비교

- 배열 => 상자를 순서대로 나열한 데이터의 구조 | 몇 번째 상자 인지만 알면 해당 상자에 해당하는 요소를 가져올 수 있습니다.

- 연결 리스트 => 상자를 선으로 연결한 형태의 데이터 구조 | 상자 안의 요소를 알기 위해서는 하나씩 상자의 내부를 확인 해봐야 하는 점이 다름.

- 랜덤 접근가능(배열) , 랜덤 접근 불가능(연결 리스트)

- 결국 탐색은 배열이 빠르고(상자만 알면 요소 확인 가능), 데이터의 추가 또는 삭제(상자에 선을 연결하거나 끊어서 추가, 삭제)는 연결 리스트가 빠르다는 것을 알 수 있습니다.

<br>

### 스택(Stack)

- 스택은 가장 마지막으로 들어간 데이터가 가장 첫 번째로 나오는 성질(LIFO, Last In First Out)을 가진 자료 구조 입니다.

- 재귀 함수, 알고리즘에 사용 되며 웹 브라우저 방분 기록 등에 사용 됩니다. 

- 삽입, 삭제에 O(1), 탐색에 O(n)이 걸립니다. === 연결 리스트와 동일 시간 복잡도를 가지고 있습니다.

<br>

### 큐(Queue)

- 큐는 먼저 집어넣은 데이터가 먼저 나오는 성질(FIFO, First In First Out)을 지닌 자료 구조 입니다.

- CPU 작업을 기다리는 프로세스, 스레드 행렬, 네트워크 접속을 기다리는 행렬, 너비 우선 탐색, 캐시 등에 사용 합니다.

- 스택과는 반대가 되는 개념을 가졌으며 삽입, 삭제에 O(1), 탐색에는 O(n)이 걸립니다. === 시간 복잡도는 연결 리스트, 스택과 동일.

<img src="../../Images/Data Structure/stackqueue.png" />

<br>

### 비선형 자료구조

- 비선형 자료 구조란 일렬로 나열하지 않고 자료 순서나 관계가 복잡한 구조를 가진 것을 말합니다.

- 트리, 그래프가 이에 해당 됩니다.

<br>

### 그래프(Graph)

- 그래프는 정점 & 간선으로 이루어진 자료 구조를 말합니다.

- A <=> B(양방향 간선) 로 이동 할 때, A,B 는 정점(vertex), <=> 는 간선(edge)이 됩니다.

- 한 곳으로 이동하는 A => B 와 같은 경우를 단방향 간선 이라고 합니다.

- 정점으로 부터 나가는 간선을 해당 정점의 outDegree 라고 하며, 들어오는 간선을 해당 정점의 inDegree 라고 합니다.

- 정점의 약자는  V & U 라고 합니다. 위 설명한 정점과 간선으로 이루어진 집합을 그래프라고 합니다.

<br>

    - 가중치: 가중치란 간선과 정점 사이에 드는 비용을 말합니다. A노드에서 B노드로의 가는 비용이 한 칸 이라고 하면 가중치는 한 칸 입니다.

<br>

### 트리(Tree)

- 트리는 그래프 중 하나로 그래프의 특징과 같이 정점과 간선으로 이루어져 있으며, 트리 구조로 배열된 계층적 데이터의 집합을 말합니다.

- 루트 노드, 내부 노드, 리프 노드 등으로 구성 되어 있으며 트리로 이루어진 집합을 "숲" 이라고 합니다.

<br>

#### 트리의 특징?

- 부모, 자식의 계층 구조를 가집니다. 같은 경로 상의 어떤 노드 보다 위에 있으면 부모, 아래에 있으면 자식 노드가 됩니다. 

- V(노드의 수) - 1 = E(간선의 개수) 라는 특징이 있습니다. 간선의 수는 노드 수 -1 입니다.

- 임의의 두 노드 사이의 경로는 유일무이 하게 존재 합니다. 경로는 반드시 존재 합니다.

<br>

#### 트리의 구성

- 트리는 루트 노드, 내부 노드, 리프 노드로 이루어져 있습니다.

<br>

```

- 루트 노드: 가장 위에 존재하는 노드를 말합니다. 트리 문제의 경우 트리를 탐색할 때 루트 노드를 중심으로 탐색하면 해결 할 수 있습니다.

= 내부 노드: 루트 노드와 리프 노드 사이에 있는 노드를 뜻합니다.

- 리프 노드: 리프 노드는 자식 노드가 없는 노드를 말합니다.

```

<br>

#### 트리의 높이와 레벨

<img src="../../Images/Data Structure/treeheightlevel.png" />

- 깊이: 트리에서의 깊이는 각 노드마다 다르며, 루트 노드부터 특정 노드까지 최단 거리로 갔을 때의 거리를 말합니다. (그림에서 A 노드의 깊이는 2 입니다.)

- 높이: 트리의 높이는 루트 노드부터 리프 노드까지 거리중 가장 긴 거리를 의미 합니다.

- 레벨: 트리의 레벨은 문제마다 조금씩 다르긴 하지만, 보통 깊이와 같은 의미를 지닙니다. P노드(루트)의 레벨이 1레벨이라고 할때, Q(내부) & R(내부)노드의 레벨은 2 레벨이 됩니다.

- 서브트리: 트리 내의 하위 집합을 서브트리라고 합니다. 트리 내에 있는 부분집합 입니다. L, E, F, G는 서브트리 입니다.

<br>
