# 자료 구조(Data Structure)

### 자료 구조란?

- 자료 구조는 효율적으로 데이터를 관리하고 수정, 삭제, 탐색, 저장 할 수 있는 데이터의 집합을 말합니다.

<br>

### 복잡도

- 복잡도는 시간 복잡도와 공간 복잡도로 나뉩니다.

<br>

#### 시간 복잡도

- 시간 복잡도란 "문제를 해결하는 데 걸리는 시간과 입력의 함수 관계"를 말합니다. 어떤 알고리즘의 로직이 얼마나 오랜 시간이 걸리는 지를 나타낼 때 사용 되며, 이를 보통 빅오 표기법으로 나타냅니다. 

- 시간 복잡도가 필요한 이유는 바로 효율적인 코드를 개선하는 데 쓰이는 척도가 되기 때문 입니다. 

<img src="../../Images/Data Structure/timecomplexity.png" />

- 위 그림을 보면 O(1)과 O(n)은 입력 크기가 커질 수록 차이가 많이 나는 것을 확인 할 수 있습니다. O(n^2), 보다 O(n), O(n) 보다 O(1)을 지향해야 합니다.

<br>

#### 공간 복잡도

- 공간 복잡도는 프로그램을 실행 시켰을 때 필요로 하는 자원 공간의 양을 말합니다.

> int a[1004]; // C++

- 위 C++ 예시에서는 a 배열은 1004 X 4 바이트의 크기를 가지게 되는데, 이러한 공간을 말합니다.

<br>

### 자료 구조에서의 시간 복잡도

- 자료 구조를 사용할 때 시간 복잡도를 잘 생각하여야 합니다.

<img src="../../Images/Data Structure/datastructurecomplexity.png">

- 위 이미지는 자주 사용 되는 자료 구조의 시간 복잡도를 나타낸 모습입니다. 시간 복잡도를 생각할 때 평균(Average), 최악(Worst)의 시간 복잡도를 고려하면서 사용 합니다.

<br>

### 선형 자료 구조

- 선형 자료 구조란 요소가 일렬로 나열 되어져 있는 자료 구조를 말합니다.

<br>

#### 연결 리스트(Linked List)

- 연결 리스트는 데이터를 감싼 노드를 포인터로 연결해서 공간 효윬성을 극대화 시킨 자료 구조 입니다. 삽입, 삭제가 O(1)이 걸리며 탐색에는 O(n)이 걸립니다.

<img src="../../Images/Data Structure/linkedlist.png"/>

```

- 싱글 연결 리스트: next 포인터 만을 가집니다.

- 이중 연결 리스트: next 포인터와 prev 포인터를 가집니다.

- 원형 이중 연결 리스트: 이중 연결 리스트와 같지만 마지막 노드의 next 포인터가 헤드(제일 첫 번째 노드) 노드를 가리킵니다.

```

<br>

### 배열(Array)

- 배열은 같은 타입의 변수들로 이루어져 있고, 크기가 정해져 있으며 인접한 메모리 위치에 있는 데이터들을 모아놓은 집합 입니다.

- 중복을 허용하고 순서가 존재 합니다.

- 탐색에 O(1)이 되어 랜덤 접근이 가능합니다. 삽입, 삭제에는 O(n)이 걸립니다. 

- 따라서 데이터 추가와 삭제를 할 때는 연결 리스트, 탐색을 할 때에는 배열로 하는 것이 좋습니다.

<br>

#### 랜덤 접근, 순차적 접근

- 직접 접근 이라고도 하는 랜덤 접근은 배열과 같은 순차적인 데이터가 있을 떄, 동일한 시간에 임의의 인덱스에 해당하는 데이터에 접근 가능한 기능을 말합니다.

- 데이터를 저장 된 순서대로만 검색해야 하는 순차적 접근과는 반대의 개념에 있습니다.

<br>

#### 배열과 연결 리스트 비교

- 배열 => 상자를 순서대로 나열한 데이터의 구조 | 몇 번째 상자 인지만 알면 해당 상자에 해당하는 요소를 가져올 수 있습니다.

- 연결 리스트 => 상자를 선으로 연결한 형태의 데이터 구조 | 상자 안의 요소를 알기 위해서는 하나씩 상자의 내부를 확인 해봐야 하는 점이 다름.

- 랜덤 접근가능(배열) , 랜덤 접근 불가능(연결 리스트)

- 결국 탐색은 배열이 빠르고(상자만 알면 요소 확인 가능), 데이터의 추가 또는 삭제(상자에 선을 연결하거나 끊어서 추가, 삭제)는 연결 리스트가 빠르다는 것을 알 수 있습니다.

<br>

### 스택(Stack)

- 스택은 가장 마지막으로 들어간 데이터가 가장 첫 번째로 나오는 성질(LIFO, Last In First Out)을 가진 자료 구조 입니다.

- 재귀 함수, 알고리즘에 사용 되며 웹 브라우저 방분 기록 등에 사용 됩니다. 

- 삽입, 삭제에 O(1), 탐색에 O(n)이 걸립니다. === 연결 리스트와 동일 시간 복잡도를 가지고 있습니다.

<br>

### 큐(Queue)

- 큐는 먼저 집어넣은 데이터가 먼저 나오는 성질(FIFO, First In First Out)을 지닌 자료 구조 입니다.

- CPU 작업을 기다리는 프로세스, 스레드 행렬, 네트워크 접속을 기다리는 행렬, 너비 우선 탐색, 캐시 등에 사용 합니다.

- 스택과는 반대가 되는 개념을 가졌으며 삽입, 삭제에 O(1), 탐색에는 O(n)이 걸립니다. === 시간 복잡도는 연결 리스트, 스택과 동일.

<img src="../../Images/Data Structure/stackqueue.png" />

<br>

### 비선형 자료구조

- 비선형 자료 구조란 일렬로 나열하지 않고 자료 순서나 관계가 복잡한 구조를 가진 것을 말합니다.

- 트리, 그래프가 이에 해당 됩니다.

<br>

### 그래프(Graph)

- 그래프는 정점 & 간선으로 이루어진 자료 구조를 말합니다.

- A <=> B(양방향 간선) 로 이동 할 때, A,B 는 정점(vertex), <=> 는 간선(edge)이 됩니다.

- 한 곳으로 이동하는 A => B 와 같은 경우를 단방향 간선 이라고 합니다.

- 정점으로 부터 나가는 간선을 해당 정점의 outDegree 라고 하며, 들어오는 간선을 해당 정점의 inDegree 라고 합니다.

- 정점의 약자는  V & U 라고 합니다. 위 설명한 정점과 간선으로 이루어진 집합을 그래프라고 합니다.

<br>

    - 가중치: 가중치란 간선과 정점 사이에 드는 비용을 말합니다. A노드에서 B노드로의 가는 비용이 한 칸 이라고 하면 가중치는 한 칸 입니다.

<br>

### 트리(Tree)

- 트리는 그래프 중 하나로 그래프의 특징과 같이 정점과 간선으로 이루어져 있으며, 트리 구조로 배열된 계층적 데이터의 집합을 말합니다.

- 루트 노드, 내부 노드, 리프 노드 등으로 구성 되어 있으며 트리로 이루어진 집합을 "숲" 이라고 합니다.

<br>

#### 트리의 특징?

- 부모, 자식의 계층 구조를 가집니다. 같은 경로 상의 어떤 노드 보다 위에 있으면 부모, 아래에 있으면 자식 노드가 됩니다. 

- V(노드의 수) - 1 = E(간선의 개수) 라는 특징이 있습니다. 간선의 수는 노드 수 -1 입니다.

- 임의의 두 노드 사이의 경로는 유일무이 하게 존재 합니다. 경로는 반드시 존재 합니다.

<br>

#### 트리의 구성

- 트리는 루트 노드, 내부 노드, 리프 노드로 이루어져 있습니다.

<br>

```

- 루트 노드: 가장 위에 존재하는 노드를 말합니다. 트리 문제의 경우 트리를 탐색할 때 루트 노드를 중심으로 탐색하면 해결 할 수 있습니다.

= 내부 노드: 루트 노드와 리프 노드 사이에 있는 노드를 뜻합니다.

- 리프 노드: 리프 노드는 자식 노드가 없는 노드를 말합니다.

```

<br>

#### 트리의 높이와 레벨

<img src="../../Images/Data Structure/treeheightlevel.png" />

- 깊이: 트리에서의 깊이는 각 노드마다 다르며, 루트 노드부터 특정 노드까지 최단 거리로 갔을 때의 거리를 말합니다. (그림에서 A 노드의 깊이는 2 입니다.)

- 높이: 트리의 높이는 루트 노드부터 리프 노드까지 거리중 가장 긴 거리를 의미 합니다.

- 레벨: 트리의 레벨은 문제마다 조금씩 다르긴 하지만, 보통 깊이와 같은 의미를 지닙니다. P노드(루트)의 레벨이 1레벨이라고 할때, Q(내부) & R(내부)노드의 레벨은 2 레벨이 됩니다.

- 서브트리: 트리 내의 하위 집합을 서브트리라고 합니다. 트리 내에 있는 부분집합 입니다. L, E, F, G는 서브트리 입니다.

<br>

### 이진 트리

- 자식 노드의 수가 두 개 이하인 트리를 의미하며 다음과 같이 분리 할 수 있습니다.

<img src="../../Images/Data Structure/allbinarytree.png" />

```

- 정이진 트리(Full Binary Tree): 자식 노드가 0 또는 두개인 이진 트리를 의미.

- 완전 이진 트리(Complete Binary Tree): 왼쪽에서 부터 채워진 이진 트리를 의미. 마지막 레벨을 제외 모든 레벨이 완전히 채워져 있으며 마지막의 경우 왼쪽 부터 채워져 있음.

- 변질 이진 트리(Degenerate Binary Tree): 자식 노드가 하나 밖에 없는 이진 트리를 의미.

- 포화 이진 트리(Perfect Binary Tree): 모든 노드가 꽉 차 있는 이진 트리를 의미.

- 균형 이진 트리(Balanced Binary Tree): 왼쪽, 오른쪽 노드의 높이차이가 1 이하인 이진트리를 의미. map, set => 레드 블랙 트리(군형 이진 트리 중 하나)

```

<br>

### 이진 탐색 트리

- 이진 탐색 트리(BST)란 노드의 오른쪽 하위 트리에는 노드 값보다 큰 값이 있는 노드만 포함되고, 왼쪽 하위 트리에는 노드 값 보다 작은 값이 들어 있는 트리를 의미합니다.

<img src="../../Images/Data Structure/bst.png" />

- "검색" 하기에 용이 합니다. 왼쪽에는 작은 값, 오른 쪽에는 큰 값이 이미 정해져 있기 때문에, 그림에서 2를 찾으려고 한다면 루트 노드의 왼쪽만 살펴보면 되기 때문 입니다.

- 보통 요소를 찾을 떄 이진 탐색 트리의 경우 O(logn)이 소요 됩니다. 최악의 경우 O(n)이 소요 됩니다.

<img src="../../Images/Data Structure/linearitybst.png" />

- 이진 탐색 트리는 삽입 순서에 따라 선형적일 수 있기 때문에 소요 시간의 차이가 있는데, 위 이미지가 선형적인 이진 탐색 트리 입니다.

- 왼쪽 평균과 같은 경우 루트 노드 요소 보다 큰 요소는 하나 밖에 없기 때문에 쉽게 찾을 수 있지만 작은 노드가 모든 왼쪽에 몰려 있습니다.

- 오른쪽 최악의 경우에는 모든 노드의 요소가 루트 노드 요소보다 크기 떄문에, 6을 찾기 위해서 모든 노드의 요소를 탐색 해야만 합니다.

<br>

#### AVL 트리

- AVL 트리(Adelson-Velsky and Landis tree)는 앞에 말한 최악의 경우 선형적인 트리가 되는 것을 방지하고 스스로 균형을 잡는 이진 탐색 트리 입니다.

- 두 자식 서브트리의 높이는 항상 최대 1만큼 차이가 난다는 특징을 가집니다.

- 탐색, 삽입, 삭제 모두 O(logn)을 가지며 균형이 맞지 않는 것을 맞추기 위해 트리 일부를 왼쪽, 오른쪽으로 회전 시키며 균형을 잡습니다.

<br>

#### 레드 블랙 트리

- 레드 블랙 트리는 균형 이진 탐색 트리로 탐색, 삽입, 삭제 모두 시작 복잡도가 O(logn)을 가집니다. 각 노드는 빨강, 또는 검은색을 나타내는 추가 비트를 저장 합니다.

- 삽입, 삭제 중에 트리가 균형을 유지하도록 하는 것이 특징 입니다.

- 루트 노드와 리프노드는 항상 블랙 이고, 어떤 노드가 레드라면 그 자식 노드는 반드시 블랙이라는 규칙을 가지고 균형을 잡는 트리 입니다.

<img src="../../Images/Data Structure/redblacktree.png" />

<br>

### 힙(Heap)

- 힙은 완전 이진 트리 기반의 자료 구조이며 최소힙과 최대힙 두 가지가 있습니다. 해당 힙에 따라 특정한 특징을 지닌 트리를 말합니다.

- 최대힙: 루트 노드에 있는 키는 모든 자식에 있는 키 중에서 가장 커야 합니다.

- 최소힙: 최소힙에서 루트 노드에 있는 키는 모든 자식에 있는 키 중에서 최솟값이어야 합니다. 또한 각 노드의 자식 노드와의 관계도 이 특징이 재귀적으로 이루어져야 합니다.

<br>

#### 최대힙의 삽입 & 삭제

- 힙에 새로운 요소가 들어오면, 우선 새로운 노드를 힙의 마지막 노드에 이어서 삽입 합니다.

- 새로운 노드를 부모 노드들과의 크기를 비교해가며 교환하여 힙의 성질을 만족 시킵니다.

- 최대힙에서 최댓값은 루트 노드이므로 루트 노드가 삭제되고, 이후 마지막 노드와 루트 노드를 스왑 => 또 다시 스왑 하는 과정을 거쳐 재구성 합니다.

<br>

### 우선순위 큐

- 우선순위 대기열 이라고도하며, 대기열에서 우선순위가 높은 요소가 우선 순위가 낮은 요소보다 먼저 제공 되는 자료구조.

- 우선순위 큐는 힙을 기반으로 구현 됩니다.

<img src="../../Images/Data Structure/priorityqueue.png" />

<br>

### 맵(map)

- 맵은 특정 순서에 따라 키와 매핑된 값의 조합으로 형성 된 자료 구조 입니다. 레드 블랙 트리 자료 구조를 기반으로 형성 됩니다.

<br>

```
//JavaScript에서 Map 객체는 다음과 같은 주요 메서드를 제공합니다.

- set(key, value): 특정 키에 값을 설정합니다. 만약 해당 키가 이미 존재한다면 값을 업데이트합니다.

- get(key): 특정 키에 대한 값을 반환합니다. 해당 키가 없으면 undefined를 반환합니다.

- has(key): 특정 키가 존재하는지 여부를 확인합니다.

- delete(key): 특정 키와 해당 값을 삭제합니다.

- clear(): Map 내의 모든 키-값 쌍을 제거합니다.

- size: Map 내의 키-값 쌍의 개수를 반환합니다.

```

<br>

### 셋(set)

- 셋(set)은 특정 순서에 따라 고유한 요소를 저장하는 컨테이너 입니다. 중복되는 요소 없이 Unique 값만 저장하는 자료구조 입니다.

<br>

```
//JavaScript에서 Set 객체는 다음과 같은 주요 메서드를 제공합니다.

- add(value): 새로운 값을 Set에 추가합니다. 이미 존재하는 값이면 추가되지 않습니다.

- has(value): 특정 값이 Set에 존재하는지 여부를 확인합니다.

- delete(value): 특정 값이 Set에서 제거됩니다.

- clear(): Set 내의 모든 값을 제거합니다.

- size: Set 내의 값의 개수를 반환합니다.

- forEach(callbackFn): Set 내의 각 값을 반복적으로 처리합니다.

```

<br>

### 해시 테이블

- 해시 테이블은 무한에 가까운 데이터를 유한한 개수의 해시 값으로 매핑한 테이블을 말합니다.

- 삽입, 삭제, 탐색 시 평균적으로 O(1)의 시간 복잡도를 가집니다.

- JavaScript 에서 객체(Object)는 해시 테이블의 일종으로 볼 수 있습니다.
